<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gscripter</title>
    <link rel="icon" href="./gscripter.ico" type="image/x-icon">


    <!-- ACE Editor Core -->
    <script src="./ace/ace.js"></script>
    <script src="./ace/ext-searchbox.js"></script>
    <script src="./ace/ext-language_tools.js"></script>
    <script src="./ace/ext-modelist.js"></script>
    <script src="./ace/theme/theme-monokai.js"></script>

    <!-- ACE Language Modes -->
    <script src="./ace/mode-javascript.js"></script>
    <script src="./ace/mode-html.js"></script>
    <script src="./ace/mode-css.js"></script>
    <script src="./ace/mode-python.js"></script>
    <script src="./ace/mode-java.js"></script>
    <script src="./ace/mode-typescript.js"></script>
    <script src="./ace/mode-php.js"></script>
    <script src="./ace/mode-ruby.js"></script>
    <script src="./ace/mode-golang.js"></script>
    <script src="./ace/mode-sql.js"></script>
    <script src="./ace/mode-markdown.js"></script>
    <script src="./ace/mode-json.js"></script>
    <script src="./ace/mode-xml.js"></script>

    
    <!-- Font Awesome for Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">


    <style>

    /* Theme Variables
    -------------------------------------------------- */
    :root {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --text-primary: #ffffff;
        --text-secondary: #888;
        --accent: #404040;
        --accent-hover: #505050;
        --success: #2ecc71;
        --success-dark: #27ae60;
        --border: #3d3d3d;
        --handle-width: 12px;
    }

    /* Base Styles
    -------------------------------------------------- */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        font-family: 'Arial', sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* Toolbar Styles
    -------------------------------------------------- */
    .toolbar {
        background-color: var(--bg-secondary);
        padding: 6px 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--border);
        height: 32px;
        z-index: 10;
    }

    .toolbar-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .toolbar-button {
        background-color: transparent;
        color: var(--text-primary);
        border: none;
        width: 32px;
        height: 32px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
    }

    .toolbar-button:hover {
        background-color: var(--accent);
    }

    .toolbar-button i {
        font-size: 14px;
    }

    .toolbar-button.active {
        background-color: var(--accent);
    }

    /* File Info Styles
    -------------------------------------------------- */
    .file-info {
        color: var(--text-secondary);
        font-size: 0.9em;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .current-file {
        color: var(--text-primary);
        font-style: italic;
    }

    /* Workspace Layout
    -------------------------------------------------- */
    .workspace {
        flex: 1;
        display: flex;
        position: relative;
        overflow: hidden;
    }

    .editor-container {
        flex: 1;
        position: relative;
        display: flex;
    }

    #editor {
        flex: 1;
    }

    /* Side Pane Styles
    -------------------------------------------------- */
    .side-pane {
        position: relative;
        width: 0;
        background-color: var(--bg-secondary);
        overflow: hidden;
        transition: width 0.3s ease;
        flex-shrink: 0;
    }

    .side-pane.visible {
        width: 300px;
    }

    .side-pane-content {
        position: absolute;
        top: 0;
        left: var(--handle-width);
        right: 0;
        bottom: 0;
        overflow-y: auto;
        padding: 16px;
    }

    /* Resize Handle Styles
    -------------------------------------------------- */
    .resize-handle-container {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        width: var(--handle-width);
        background-color: var(--bg-secondary);
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
        cursor: col-resize;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }

    .resize-handle-container:hover {
        background-color: var(--accent);
    }

    .resize-handle-container::before {
        content: "";
        width: 2px;
        height: 30px;
        background-color: var(--border);
        border-radius: 1px;
    }

    .resize-handle-container:hover::before {
        background-color: var(--text-secondary);
    }

    /* Status Bar Styles
    -------------------------------------------------- */
    .status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 28px;
        background-color: var(--bg-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        color: var(--text-secondary);
        border-top: 1px solid var(--border);
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(100%);
        z-index: 20;
    }

    .status-bar.saved {
        background-color: var(--success);
        color: white;
        opacity: 1;
        transform: translateY(0);
    }

    /* Utility Styles
    -------------------------------------------------- */
    #file-input {
        display: none;
    }

    /* ACE Editor Overrides
    -------------------------------------------------- */
    .ace_search {
        background-color: var(--bg-secondary) !important;
        border: 1px solid var(--border) !important;
        color: var(--text-primary) !important;
    }

    .ace_search_field {
        background-color: var(--accent) !important;
        color: var(--text-primary) !important;
        border: 1px solid var(--border) !important;
    }

    .ace_button {
        color: var(--text-primary) !important;
        border: 1px solid var(--border) !important;
        background-color: var(--accent) !important;
    }

    .ace_button:hover {
        background-color: var(--accent-hover) !important;
    }
    
    .ace_bracket {
        margin: 0 !important;
        border: none !important;
        background-color: rgba(255, 140, 0, 0.8) !important;
        border-radius: 2px !important;
    }
    
    /* Tooltip Styles
    -------------------------------------------------- */
    .tooltip {
        position: relative;
    }

    .tooltip:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: -25px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--bg-secondary);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
    }

    /* SCROLLBAR Styles
    -------------------------------------------------- */
    #editor .ace_scrollbar {
        width: 30px !important;
    }
    
    #editor .ace_scrollbar::-webkit-scrollbar {
        width: 30px !important;
    }
    
    #editor .ace_scrollbar::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 5px;
    }
    
    #editor .ace_scrollbar::-webkit-scrollbar-thumb:hover {
        background: var(--accent-hover);
    }
    
    #editor .ace_scrollbar::-webkit-scrollbar-track {
        background: var(--bg-secondary);
    }
    
    /* Firefox specific */
    #editor .ace_scrollbar {
        scrollbar-color: var(--accent) var(--bg-secondary);
        scrollbar-width: auto;
    }

    /* SidePane TAB Styles
    -------------------------------------------------- */

    .tab-container {
        position: absolute;
        top: 0;
        left: var(--handle-width);
        right: 0;
        height: 30px;
        background-color: var(--bg-secondary);
        border-bottom: 1px solid var(--border);
        display: flex;
        padding: 0px;
        gap: 5px;
    }

    .tab {
        padding: 8px 10px;
        background-color: var(--accent);
        color: var(--text-primary);
        border-radius: 4px 4px 0 0;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .tab.active {
        background-color: var(--bg-primary);
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
    }

    .status-dot.green {
        background-color: #2ecc71;
    }

    .status-dot.red {
        background-color: #ff5555;
    }
        
    .tab:hover:not(.active) {
        background-color: var(--accent-hover);
    }

    .tab-content {
        position: absolute;
        top: 30px;
        left: var(--handle-width);
        right: 0;
        bottom: 0;
        overflow-y: auto;
        padding: 1px;
    }



    /* SidePane TAB Styles
    -------------------------------------------------- */

    .ast-tree {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
    }
    
    .ast-node-container {
        margin: 4px 0;
    }
    
    .ast-node {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .ast-node:hover {
        background-color: var(--accent);
    }
    
    .ast-node.active {
        background-color: var(--accent);
        border-left: 3px solid #42a5f5;
    }
    
    .ast-toggle {
        display: inline-block;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        margin-right: 8px;
        font-size: 12px;
        color: var(--text-secondary);
        user-select: none;
    }
    
    .ast-content {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .ast-children {
        margin-left: 20px;
        border-left: 1px solid var(--border);
        padding-left: 8px;
    }
    
    .classdeclaration-node { 
        color: #ffca28; 
    }
    .methoddeclaration-node { 
        color: #42a5f5;
    }
    
    .ast-loading, .ast-error, .ast-empty {
        padding: 16px;
        color: var(--text-secondary);
        font-style: italic;
    }
    
    .ast-error {
        color: #ff5555;
    }
    
    
    
    /* Ace Overrides
    -------------------------------------------------- */    
    
    .ace_marker-layer .ace_selected-word {
        background-color: #ff5555 !important; /* Red */
        opacity: 0.5 !important;
    }
    
    .ace_marker-layer .ace_selection {
        background-color: ##70563e !important;
        opacity: 1 !important;
        border: 1px solid #ffffff !important;
    }
 
 
    /* AI TABS
    -------------------------------------------------- */   
    
    .ai-tab-container {
        position: absolute;
        top: 40px;
        left: var(--handle-width);
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
    }
    
    .ai-content {
        flex: 1;
        overflow-y: auto;
        padding: 0;
    }
    
    .ai-nav-pane {
        height: 35px;
        background-color: var(--bg-secondary);
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 0px;
        z-index: 20;
        margin-left: -12px;
    }
    
    .ai-nav-button {
        background-color: var(--accent);
        color: var(--text-primary);
        border: none;
        padding: 6px 6px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .ai-nav-button:hover {
        background-color: var(--accent-hover);
    }
    
    .ai-nav-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    #grokContent.tab-content,
    #claudeContent.tab-content {
        padding: 0;
        
    }

    .live-preview-container::-webkit-scrollbar {
        width: 10px;
    }

    .live-preview-container::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 4px;
    }

    .live-preview-container::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 4px;
        border: 2px solid var(--bg-secondary);
        min-height: 30px;
    }

    .live-preview-container::-webkit-scrollbar-thumb:hover {
        background: var(--accent-hover);
    }

    .live-preview-container {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
    }


    /* AST Viewer Scrollbar */
    #astContent::-webkit-scrollbar {
        width: 10px;
    }
    #astContent::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 4px;
    }
    #astContent::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 4px;
        border: 2px solid var(--bg-secondary);
        min-height: 30px;
    }
    #astContent::-webkit-scrollbar-thumb:hover {
        background: var(--accent-hover);
    }
    #astContent {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
    }
    
    
    /* Settings Window
    -------------------------------------------------- */       
    
    .settings-window {
        position: absolute;
        top: 50%;
        left: 50%;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 0;
        width: 700px;
        min-height: 300px;
        max-height: 90vh;
        overflow: hidden;
        z-index: 1000;
        display: none;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        resize: both;
        overflow: auto;
        flex-direction: column;
    }
    
    .settings-window.visible {
        display: flex;
    }
    
    .settings-window h3 {
        margin-bottom: 15px;
        color: var(--text-primary);
    }
    
    .settings-field {
        display: flex;
        flex-direction: column;
        margin-bottom: 0;
    }
    
    .settings-field label {
        display: block;
        margin-bottom: 5px;
        color: var(--text-secondary);
    }
    
    .settings-field input {
        width: 100%;
        padding: 6px;
        background-color: var(--accent);
        border: 1px solid var(--border);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: 'Courier New', monospace;
    }
    
    .settings-buttons {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        padding: 10px 20px;
        border-top: 1px solid var(--border);
        background-color: var(--bg-secondary);
        flex-shrink: 0;
        position: sticky;
        bottom: 0;
    }
    
    .settings-button {
        padding: 8px 16px;
        background-color: var(--accent);
        border: 1px solid var(--border);
        border-radius: 4px;
        color: var(--text-primary);
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 13px;
    }
    
    .settings-button:hover {
        background-color: var(--accent-hover);
    }
    
    
    .settings-field .browse-button {
        margin-left: 10px;
        padding: 6px 12px;
        background-color: var(--accent);
        border: 1px solid var(--border);
        border-radius: 4px;
        color: var(--text-primary);
        cursor: pointer;
        transition: background-color 0.2s;
    }
    
    .settings-field .browse-button:hover {
        background-color: var(--accent-hover);
    }
    
    .settings-field {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
    }
    
    .settings-header {
        background-color: var(--bg-primary);
        padding: 10px 15px;
        border-bottom: 1px solid var(--border);
        cursor: move;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
        flex-shrink: 0;
    }
    
    .settings-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 16px;
        cursor: pointer;
        padding: 0 5px;
        transition: color 0.2s;
    }
    
    .settings-close:hover {
        color: var(--text-primary);
    }
    
    .settings-content {
        padding: 20px;
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    
    .settings-input-container {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    
    .settings-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .settings-field input {
        flex: 1;
    }
    
    .download-button {
        display: flex;
        align-items: center;
        gap: 8px;
        background: #444;
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        text-decoration: none;
        font-weight: 500;
        transition: background 0.2s;
    }
    
    .download-button:hover {
        background: #555;
    }
    
    .settings-section {
        margin: 16px 0;
        padding-top: 12px;
        border-top: 1px solid #333;
    }
    
    .settings-section h4 {
        margin-top: 0;
        margin-bottom: 12px;
        color: #ccc;
    }

    .button-hover {
        transition: transform 0.2s ease-in-out;
    }

    </style>
</head>
<body>
<div class="toolbar">
    <div class="toolbar-buttons">
        <button class="toolbar-button tooltip" onclick="TextEditor.openFile()" data-tooltip="Open File (Ctrl+O)">
            <i class="fas fa-folder-open"></i>
        </button>
        <button class="toolbar-button tooltip" onclick="TextEditor.saveFile()" data-tooltip="Save (Ctrl+S)">
            <i class="fas fa-save"></i>
        </button>
        <button class="toolbar-button tooltip" onclick="TextEditor.saveFileAs()" data-tooltip="Save As (Ctrl+Shift+S)">
            <i class="fas fa-file-export"></i>
        </button>
        <button class="toolbar-button tooltip" onclick="TextEditor.toggleWordWrap()" data-tooltip="Toggle Word Wrap">
            <i class="fas fa-align-left"></i>
        </button>
        <button class="toolbar-button tooltip" id="toggleSidePane" onclick="TextEditor.toggleSidePane()" data-tooltip="Toggle Side Pane">
            <i class="fas fa-columns"></i>
        </button>
        <!-- Prompt button will be added by JS -->
    </div>
    <!-- TabManager will insert tab elements here -->
</div>
<div class="workspace">
    <div class="editor-container" id="editor">
        <!-- Editor instances will be inserted here -->
    </div>
    <div class="side-pane" id="sidePane">
        <div class="resize-handle-container" id="resizeHandle"></div>
        <div class="tab-container">
            <div class="tab" data-tab="ast">
                <span>AST</span>
            </div>
            <div class="tab" data-tab="grok">
                <span class="status-dot red"></span>
                <span>Grok</span>
            </div>
            <div class="tab" data-tab="claude">
                <span class="status-dot red"></span>
                <span>Claude</span>
            </div>
            <div class="tab" data-tab="chatgpt">
                <span class="status-dot red"></span>
                <span>ChatGPT</span>
            </div>
            <div class="tab" data-tab="gemini">
                <span class="status-dot red"></span>
                <span>Gemini</span>
            </div>
            <div class="tab" data-tab="live">
                <span>Live</span>
            </div>
        </div>
        <div class="tab-content" id="astContent"></div>
        <div class="tab-content" id="grokContent" style="display: none;">
            <div class="ai-tab-container">
                <div class="ai-content">
                    <!-- Grok content will be inserted here by JavaScript -->
                </div>
                <div class="ai-nav-pane">
                    <!-- Navigation will be inserted by JavaScript -->
                </div>
            </div>
        </div>
        <div class="tab-content" id="claudeContent" style="display: none;">
            <div class="ai-tab-container">
                <div class="ai-content">
                    <!-- Claude content will be inserted here by JavaScript -->
                </div>
                <div class="ai-nav-pane">
                    <!-- Navigation will be inserted by JavaScript -->
                </div>
            </div>
        </div>
        <div class="tab-content" id="chatGPTContent" style="display: none;">
            <div class="ai-tab-container">
                <div class="ai-content">
                    <!-- ChatGPT content will be inserted here by JavaScript -->
                </div>
                <div class="ai-nav-pane">
                    <!-- Navigation will be inserted by JavaScript -->
                </div>
            </div>
        </div>
        <div class="tab-content" id="geminiContent" style="display: none;">
            <div class="ai-tab-container">
                <div class="ai-content">
                    <!-- Gemini content will be inserted here by JavaScript -->
                </div>
                <div class="ai-nav-pane">
                    <!-- Navigation will be inserted by JavaScript -->
                </div>
            </div>
        </div>
        <div class="tab-content" id="liveContent" style="display: none;">
            <!-- Live preview content will be inserted here by JavaScript -->
        </div>
    </div>
</div>
<div class="status-bar" id="statusBar"></div>

<script>

class Settings {
    constructor() {
        this.storageDirectory = localStorage.getItem('storageDirectory') || this.getDefaultDirectory();
        this.useStorageDirectory = localStorage.getItem('useStorageDirectory') !== 'false';
        this.dirHandle = null;
        this.lastDirHandle = null;
    }

    getDefaultDirectory() {
        return 'desktop';
    }

    setStorageDirectory(path) {
        const normalizedPath = path.replace(/[\\/]+/g, window.navigator.platform.includes('Win') ? '\\' : '/');
        this.storageDirectory = normalizedPath;
        localStorage.setItem('storageDirectory', normalizedPath);
        this.dirHandle = null;
    }

    getStorageDirectory() {
        return this.storageDirectory;
    }

    setUseStorageDirectory(value) {
        this.useStorageDirectory = value;
        localStorage.setItem('useStorageDirectory', value);
    }

    getUseStorageDirectory() {
        return this.useStorageDirectory;
    }

    setLastDirHandle(handle) {
        this.lastDirHandle = handle;
    }

    getLastDirHandle() {
        return this.lastDirHandle;
    }

    setDirHandle(handle) {
        this.dirHandle = handle;
    }

    getEffectiveDirHandle() {
        return this.useStorageDirectory ? this.dirHandle : this.lastDirHandle;
    }

    getEffectiveStartIn() {
        const path = this.getStorageDirectory().toLowerCase();
        if (this.getEffectiveDirHandle()) return this.getEffectiveDirHandle();
        if (path.includes('desktop')) return 'desktop';
        if (path.includes('documents')) return 'documents';
        if (path.includes('downloads')) return 'downloads';
        return undefined;
    }
}



class SidePane {
    constructor(editor) {
        this.editor = editor;
        this.isResizing = false;
        this.initialWidth = null;
        this.initialX = null;
        this.connectionTimeout = 5000;
        this.grokLastActive = 0;
        this.claudeLastActive = 0;
        this.chatGPTLastActive = 0;
        this.geminiLastActive = 0;

        this.paneElement = document.getElementById('sidePane');
        this.resizeHandle = document.getElementById('resizeHandle');
        this.toggleButton = document.getElementById('toggleSidePane');
        this.workspace = document.querySelector('.workspace');
        this.grokContent = document.getElementById('grokContent');
        this.claudeContent = document.getElementById('claudeContent');
        this.chatGPTContent = document.getElementById('chatGPTContent');
        this.geminiContent = document.getElementById('geminiContent');
        this.astContent = document.getElementById('astContent');

        this.liveContent = document.createElement('div');
        this.liveContent.id = 'liveContent';
        this.paneElement.appendChild(this.liveContent);

        this.initializeTabs();
        this.grok = new Grok(this.grokContent);
        this.claude = new Claude(this.claudeContent);
        this.chatGPT = new ChatGPT(this.chatGPTContent);
        this.gemini = new Gemini(this.geminiContent);
        this.astViewer = new ASTViewer(this.astContent, this.editor);
        this.livePreview = new LivePreview(this.liveContent, this.editor);

        this.switchTab('ast');
        this.setupEventListeners();
        this.setupConnectionMonitoring();
        this.restoreState();
    }

    initializeTabs() {
        const tabContainer = this.paneElement.querySelector('.tab-container');
        const tabs = [
            { name: 'ast', label: 'AST' },
            { name: 'grok', label: 'Grok', hasStatus: true },
            { name: 'claude', label: 'Claude', hasStatus: true },
            { name: 'chatgpt', label: 'ChatGPT', hasStatus: true },
            { name: 'gemini', label: 'Gemini', hasStatus: true },
            { name: 'live', label: 'Live' }
        ];

        tabContainer.innerHTML = '';
        tabs.forEach(tab => {
            const tabElement = document.createElement('div');
            tabElement.className = 'tab';
            tabElement.dataset.tab = tab.name;

            if (tab.hasStatus) {
                const dot = document.createElement('span');
                dot.className = 'status-dot red';
                tabElement.appendChild(dot);
                if (tab.name === 'grok') this.grokStatusDot = dot;
                else if (tab.name === 'claude') this.claudeStatusDot = dot;
                else if (tab.name === 'chatgpt') this.chatGPTStatusDot = dot;
                else if (tab.name === 'gemini') this.geminiStatusDot = dot;
            }

            const label = document.createElement('span');
            label.textContent = tab.label;
            tabElement.appendChild(label);
            tabContainer.appendChild(tabElement);
        });

        this.tabs = tabContainer.querySelectorAll('.tab');
    }

    setupEventListeners() {
        this.resizeHandle.addEventListener('mousedown', this.handleResizeStart.bind(this));
        document.addEventListener('mousemove', this.handleResizeMove.bind(this));
        document.addEventListener('mouseup', this.handleResizeEnd.bind(this));

        this.tabs.forEach(tab => {
            tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });

        window.addEventListener('resize', () => {
            if (this.isVisible()) {
                this.validateWidth();
            }
        });
    }


    setupConnectionMonitoring() {
        this.connectionTimeout = 5000;
        this.grokLastActive = 0;
        this.claudeLastActive = 0;
        this.chatGPTLastActive = 0;
        this.geminiLastActive = 0;
    
        window.addEventListener('message', (event) => {
            const now = Date.now();
            if (event.data.type === 'grokPing') {
                this.grokLastActive = now;
                this.updateStatusDots();
            }
            else if (event.data.type === 'claudePing') {
                this.claudeLastActive = now;
                this.updateStatusDots();
            }
            else if (event.data.type === 'chatgptPing') {
                this.chatGPTLastActive = now;
                this.updateStatusDots();
            }
            else if (event.data.type === 'geminiPing') {
                this.geminiLastActive = now;
                this.updateStatusDots();
            }
            else if (event.data.type === 'chatgptExtensionReady') {
                this.chatGPTLastActive = now;
                this.updateStatusDots();
                console.log('[SidePane] ChatGPT extension ready event received');
            }
            else if (event.data.type === 'geminiExtensionReady') {
                this.geminiLastActive = now;
                this.updateStatusDots();
                console.log('[SidePane] Gemini extension ready event received');
            }
            else if (event.data.type === 'grokMessage' || event.data.type === 'grokStatus') {
                this.grokLastActive = now;
                this.updateStatusDots();
            }
            else if (event.data.type === 'claudeMessage' || event.data.type === 'claudeStatus') {
                this.claudeLastActive = now;
                this.updateStatusDots();
            }
            else if (event.data.action === 'sendMessageToIndex') {
                if (event.data.source === 'chatgpt') {
                    this.chatGPTLastActive = now;
                    console.log('[SidePane] ChatGPT message received at:', new Date().toISOString());
                    this.updateStatusDots();
                }
                else if (event.data.source === 'gemini') {
                    this.geminiLastActive = now;
                    console.log('[SidePane] Gemini message received at:', new Date().toISOString());
                    this.updateStatusDots();
                }
            }
        });
    
        setInterval(() => this.updateStatusDots(), 1000);
    }

    updateStatusDots() {
        const now = Date.now();
        const grokActive = (now - this.grokLastActive) < this.connectionTimeout;
        const claudeActive = (now - this.claudeLastActive) < this.connectionTimeout;
        const chatGPTActive = (now - this.chatGPTLastActive) < this.connectionTimeout;
        const geminiActive = (now - this.geminiLastActive) < this.connectionTimeout;

        const updateDot = (dot, isActive, lastState) => {
            const wasGreen = lastState !== false;
            if (isActive && !wasGreen) {
                dot.classList.add('green');
                dot.classList.remove('red');
            } else if (!isActive && wasGreen) {
                dot.classList.add('red');
                dot.classList.remove('green');
                setTimeout(() => {
                    const currentTime = Date.now();
                    if ((currentTime - (dot === this.grokStatusDot ? this.grokLastActive : 
                        dot === this.claudeStatusDot ? this.claudeLastActive : 
                        dot === this.chatGPTStatusDot ? this.chatGPTLastActive : 
                        this.geminiLastActive)) >= this.connectionTimeout) {
                        this.updateStatusDots();
                    }
                }, 1000);
            }
        };

        if (this.grokStatusDot) {
            updateDot(this.grokStatusDot, grokActive, this.grokStatusDot.classList.contains('green'));
        }
        if (this.claudeStatusDot) {
            updateDot(this.claudeStatusDot, claudeActive, this.claudeStatusDot.classList.contains('green'));
        }
        if (this.chatGPTStatusDot) {
            updateDot(this.chatGPTStatusDot, chatGPTActive, this.chatGPTStatusDot.classList.contains('green'));
        }
        if (this.geminiStatusDot) {
            updateDot(this.geminiStatusDot, geminiActive, this.geminiStatusDot.classList.contains('green'));
        }
    }

    switchTab(tabName) {
        this.tabs.forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tab === tabName);
        });

        this.grokContent.style.display = tabName === 'grok' ? 'block' : 'none';
        this.claudeContent.style.display = tabName === 'claude' ? 'block' : 'none';
        this.chatGPTContent.style.display = tabName === 'chatgpt' ? 'block' : 'none';
        this.geminiContent.style.display = tabName === 'gemini' ? 'block' : 'none';
        this.astContent.style.display = tabName === 'ast' ? 'block' : 'none';
        this.liveContent.style.display = tabName === 'live' ? 'block' : 'none';

        this.grokContent.offsetHeight;
        this.claudeContent.offsetHeight;
        this.chatGPTContent.offsetHeight;
        this.geminiContent.offsetHeight;
        this.astContent.offsetHeight;
        this.liveContent.offsetHeight;

        if (tabName === 'ast') {
            this.astViewer.updateAST();
        } else if (tabName === 'live') {
            this.livePreview.show();
        } else {
            this.livePreview.hide();
        }
    }

    restoreState() {
        const isVisible = localStorage.getItem('sidePaneVisible') === 'true';
        const savedWidth = localStorage.getItem('sidePaneWidth');
        
        if (isVisible) {
            this.paneElement.classList.add('visible');
            this.toggleButton.classList.add('active');
            if (savedWidth) {
                this.paneElement.style.width = savedWidth;
            }
        }
    }

    handleResizeStart(e) {
        this.isResizing = true;
        this.initialX = e.clientX;
        this.initialWidth = this.paneElement.offsetWidth;

        document.body.style.cursor = 'col-resize';
        this.resizeHandle.classList.add('dragging');
        document.body.style.userSelect = 'none';

        const livePreview = document.querySelector('.live-preview-container');
        if (livePreview) {
            livePreview.classList.add('dragging');
        }
    }

    handleResizeMove(e) {
        if (!this.isResizing) return;

        const livePreview = document.querySelector('.live-preview-container');
        if (livePreview && !livePreview.classList.contains('dragging')) {
            livePreview.classList.add('dragging');
        }

        const deltaX = this.initialX - e.clientX;
        let newWidth = this.initialWidth + deltaX;

        const maxWidth = this.workspace.offsetWidth - 200;
        newWidth = Math.min(Math.max(100, newWidth), maxWidth);

        this.paneElement.style.width = `${newWidth}px`;
        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.resize();
        }
    }

    handleResizeEnd() {
        if (!this.isResizing) return;

        this.isResizing = false;
        document.body.style.cursor = '';
        this.resizeHandle.classList.remove('dragging');
        document.body.style.userSelect = '';

        const livePreview = document.querySelector('.live-preview-container');
        if (livePreview) {
            livePreview.classList.remove('dragging');
        }

        localStorage.setItem('sidePaneWidth', this.paneElement.style.width);
    }

    validateWidth() {
        const maxWidth = this.workspace.offsetWidth - 200;
        const currentWidth = this.paneElement.offsetWidth;

        if (currentWidth > maxWidth) {
            this.paneElement.style.width = `${maxWidth}px`;
            localStorage.setItem('sidePaneWidth', `${maxWidth}px`);
            const activeEditor = this.editor.getActiveEditor();
            if (activeEditor) {
                activeEditor.resize();
            }
        }
    }

    toggle() {
        if (this.isVisible()) {
            this.hide();
        } else {
            this.show();
        }
    }

    show() {
        const width = localStorage.getItem('sidePaneWidth') || '300px';
        this.paneElement.classList.add('visible');
        this.paneElement.style.width = width;
        this.toggleButton.classList.add('active');
        localStorage.setItem('sidePaneVisible', 'true');
        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.resize();
        }
    }

    hide() {
        this.paneElement.classList.remove('visible');
        this.toggleButton.classList.remove('active');
        this.paneElement.style.width = '0';
        localStorage.setItem('sidePaneVisible', 'false');
        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.resize();
        }
    }

    isVisible() {
        return this.paneElement.classList.contains('visible');
    }
}




class TabManager {
    constructor(textEditor) {
        this.textEditor = textEditor;
        this.tabs = new Map();
        this.activeTabId = null;
        this.tabContainer = null;
        this.tabDivider = null;
        this.nextTabId = 1;
        this.debounceUpdateTabState = this.debounce(this.updateTabState.bind(this), 100);
        this.setupTabContainer();
    }

    setupTabContainer() {
        this.tabContainer = document.createElement('div');
        this.tabContainer.className = 'editor-tabs';
    
        this.tabDivider = document.createElement('div');
        this.tabDivider.className = 'toolbar-divider';
    
        const newTabButton = document.createElement('button');
        newTabButton.className = 'toolbar-button tooltip new-tab-button';
        newTabButton.setAttribute('data-tooltip', 'New Tab');
        newTabButton.innerHTML = '<i class="fas fa-plus"></i>';
        newTabButton.addEventListener('click', () => this.createNewTab());
    
        const toolbarButtons = document.querySelector('.toolbar-buttons');
        toolbarButtons.appendChild(this.tabDivider);
        toolbarButtons.appendChild(this.tabContainer);
    
        this.tabContainer.insertAdjacentElement('afterend', newTabButton);
        this.addTabStyles();
        
        const resizeObserver = new ResizeObserver(() => this.adjustTabWidths());
        resizeObserver.observe(this.tabContainer);
    }

    addTabStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .toolbar-divider {
                width: 1px;
                height: 24px;
                background-color: var(--border);
                margin: 0 8px;
                display: inline-block;
            }
    
            .editor-tabs {
                display: inline-flex;
                gap: 4px;
                overflow-x: hidden;
                scrollbar-width: none;
                -ms-overflow-style: none;
                margin-right: 0px;
                flex-wrap: nowrap;
                width: auto;
                max-width: calc(100% - 300px);
            }
    
            .editor-tabs::-webkit-scrollbar {
                display: none;
            }
    
            .new-tab-button {
                margin-left: 4px;
            }
    
            .editor-tab {
                display: inline-flex;
                align-items: center;
                background-color: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 4px;
                padding: 4px 8px;
                color: var(--text-secondary);
                font-size: 12px;
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s ease;
                position: relative;
                flex-shrink: 1;
                min-width: 60px;
                overflow: hidden;
            }
    
            .editor-tab .tab-name {
                overflow: hidden;
                text-overflow: ellipsis;
                flex-grow: 1;
                flex-shrink: 1;
                min-width: 0;
                order: 1;
            }
    
            .editor-tab .unsaved-indicator {
                display: none;
                color: #e67e22;
                font-size: 20px;
                line-height: 0;
                flex-shrink: 0;
                margin-right: 4px;
                margin-top: -2px;
                order: 2;
            }
    
            .editor-tab.unsaved .unsaved-indicator {
                display: inline-block;
            }
    
            .editor-tab .tab-close {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 16px;
                height: 16px;
                border-radius: 3px;
                background: transparent;
                border: none;
                color: inherit;
                cursor: pointer;
                font-size: 10px;
                opacity: 0.7;
                transition: all 0.2s ease;
                flex-shrink: 0;
                order: 3;
            }
    
            .editor-tab.active {
                background-color: var(--accent);
                color: var(--text-primary);
                border-color: var(--accent-hover);
            }
    
            .editor-tab:hover {
                background-color: var(--accent-hover);
            }
    
            .tab-close:hover {
                background-color: rgba(255, 255, 255, 0.1);
                opacity: 1;
            }
    
            .toolbar-buttons {
                display: flex;
                align-items: center;
                gap: 8px;
                width: 100%;
            }
    
            .editor-container {
                position: relative;
                flex: 1;
                display: flex;
            }
    
            .editor-instance {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: none;
            }
    
            .editor-instance.active {
                display: block;
            }
        `;
        document.head.appendChild(style);
   }

    createNewTab(fileHandle = null, content = '') {
        const tabId = `tab-${this.nextTabId++}`;
        const tabElement = document.createElement('div');
        tabElement.className = 'editor-tab';
        tabElement.dataset.tabId = tabId;

        const tabName = document.createElement('span');
        tabName.className = 'tab-name';
        const name = fileHandle ? fileHandle.name : 'Untitled';
        tabName.textContent = name;

        tabElement.title = name;

        const unsavedIndicator = document.createElement('span');
        unsavedIndicator.className = 'unsaved-indicator';
        unsavedIndicator.textContent = '•';

        const closeButton = document.createElement('button');
        closeButton.className = 'tab-close';
        closeButton.innerHTML = '<i class="fas fa-times"></i>';
        closeButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeTab(tabId);
        });

        tabElement.appendChild(tabName);
        tabElement.appendChild(unsavedIndicator);
        tabElement.appendChild(closeButton);

        tabElement.addEventListener('click', () => this.activateTab(tabId));

        this.tabContainer.appendChild(tabElement);

        const editor = this.createEditorInstance(tabId);

        this.tabs.set(tabId, {
            element: tabElement,
            editor: editor,
            fileHandle: fileHandle,
            name: name,
            content: content
        });

        if (content) {
            editor.setValue(content, -1);
            editor.session.getUndoManager().reset();
        }

        this.textEditor.setupEditorCommands(editor);

        editor.session.on('change', () => {
            this.debounceUpdateTabState(tabId);
            if (this.activeTabId === tabId) {
                const mainEditor = TextEditor.instance;
                if (mainEditor.sidePane && mainEditor.sidePane.astViewer) {
                    mainEditor.sidePane.astViewer.updateAST();
                }
            }
        });

        if (!fileHandle) {
            editor.session.getUndoManager().reset();
        }
        this.updateTabState(tabId);
        this.activateTab(tabId);
        this.adjustTabWidths();

        return tabId;
    }

    createEditorInstance(tabId) {
        const container = document.createElement('div');
        container.className = 'editor-instance';
        container.id = `editor-${tabId}`;
        
        document.getElementById('editor').appendChild(container);
        
        const editor = ace.edit(container.id);
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/javascript");
        editor.setOptions({
            enableBasicAutocompletion: true,
            enableSnippets: false,
            enableLiveAutocompletion: true,
            highlightActiveLine: true,
            highlightSelectedWord: true,
            showPrintMargin: false,
            fontSize: 15,
            fontFamily: "Courier New, monospace"
        });
        
        editor.session.setUseWrapMode(true);
        
        return editor;
    }

    activateTab(tabId) {
        if (this.activeTabId) {
            const currentTab = this.tabs.get(this.activeTabId);
            if (currentTab) {
                currentTab.element.classList.remove('active');
                currentTab.editor.container.classList.remove('active');
            }
        }

        const newTab = this.tabs.get(tabId);
        if (newTab) {
            newTab.element.classList.add('active');
            newTab.editor.container.classList.add('active');
            newTab.editor.focus();
            this.activeTabId = tabId;
            TextEditor.updateFileName(newTab.name);

            this.textEditor.setupEditorCommands(newTab.editor);

            const mainEditor = TextEditor.instance;
            if (mainEditor.sidePane && mainEditor.sidePane.astViewer) {
                mainEditor.sidePane.astViewer.updateAST();
            }
            this.adjustTabWidths();
        }
    }

    getEditor(tabId) {
        const tab = this.tabs.get(tabId);
        return tab ? tab.editor : null;
    }

    getActiveEditor() {
        const tab = this.tabs.get(this.activeTabId);
        return tab ? tab.editor : null;
    }

    getFileHandle(tabId) {
        const tab = this.tabs.get(tabId);
        return tab ? tab.fileHandle : null;
    }

    updateTabState(tabId) {
        const tab = this.tabs.get(tabId);
        if (!tab) return;

        const undoManager = tab.editor.session.getUndoManager();
        const hasChanges = undoManager.hasUndo();
        const isClean = undoManager.isClean();

        tab.element.classList.toggle('unsaved', !isClean || !tab.fileHandle);
        tab.content = tab.editor.getValue();
    }

    hasUntitledUnmodifiedTab() {
        for (const [tabId, tab] of this.tabs) {
            if (!tab.fileHandle && !tab.editor.session.getUndoManager().hasUndo()) {
                return tabId;
            }
        }
        return null;
    }

    setFileHandle(tabId, fileHandle) {
        const tab = this.tabs.get(tabId);
        if (tab) {
            tab.fileHandle = fileHandle;
            tab.name = fileHandle.name;
            const nameElement = tab.element.querySelector('.tab-name');
            if (nameElement) {
                nameElement.textContent = fileHandle.name;
            }
            tab.element.title = fileHandle.name;
            if (this.activeTabId === tabId) {
                TextEditor.updateFileName(fileHandle.name);
            }
            tab.editor.session.getUndoManager().reset();
            tab.editor.session.getUndoManager().markClean();
            this.updateTabState(tabId);
        }
    }

    updateTabName(tabId, newName) {
        const tab = this.tabs.get(tabId);
        if (tab) {
            tab.name = newName;
            const nameElement = tab.element.querySelector('.tab-name');
            if (nameElement) {
                nameElement.textContent = newName;
            }
            // Update the tooltip as well
            tab.element.title = newName;
            if (this.activeTabId === tabId) {
                TextEditor.updateFileName(newName);
            }
        }
    }

    async closeTab(tabId) {
        const tab = this.tabs.get(tabId);
        if (!tab) return;

        const undoManager = tab.editor.session.getUndoManager();
        if (!undoManager.isClean()) {
            if (!confirm('You have unsaved changes. Do you want to close this tab?')) {
                return;
            }
        }

        tab.element.remove();
        tab.editor.destroy();
        tab.editor.container.remove();
        this.tabs.delete(tabId);

        if (this.activeTabId === tabId) {
            const tabIds = Array.from(this.tabs.keys());
            if (tabIds.length > 0) {
                this.activateTab(tabIds[tabIds.length - 1]);
            } else {
                this.createNewTab();
            }
        }
        this.adjustTabWidths();
    }

    debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
        };
    }

    async saveTabWithCustomFile(tabId) {
        const tab = this.tabs.get(tabId);
        if (!tab || !tab.customFileInfo) return false;
    
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: tab.customFileInfo.name,
            types: [{
              description: 'Text Files',
              accept: {
                'text/plain': [
                  '.txt', '.js', '.py', '.html', '.css',
                  '.json', '.xml', '.md', '.ts', '.php',
                  '.rb', '.go', '.sql'
                ],
              },
            }],
          });
    
          const content = tab.editor.getValue();
          const writable = await handle.createWritable();
          await writable.write(content);
          await writable.close();
    
          tab.fileHandle = handle;
          tab.name = handle.name;
          tab.customFileInfo = null;
    
          const nameElement = tab.element.querySelector('.tab-name');
          if (nameElement) {
            nameElement.textContent = handle.name;
          }
    
          tab.editor.session.getUndoManager().markClean();
          this.updateTabState(tabId);
    
          if (this.activeTabId === tabId) {
            TextEditor.updateFileName(handle.name);
          }
    
          return true;
        } catch (err) {
          if (err.name !== 'AbortError') {
            console.error('Failed to save custom file:', err);
            TextEditor.showStatusMessage('Error saving file');
          }
          return false;
        }
    }

    adjustTabWidths() {
        const tabs = this.tabContainer.querySelectorAll('.editor-tab');
        if (tabs.length === 0) return;

        const containerWidth = this.tabContainer.clientWidth;
        const totalGapWidth = (tabs.length - 1) * 4; // 4px gap between tabs
        const availableWidth = containerWidth - totalGapWidth;

        // Adjust sizing based on number of tabs
        const minTabWidth = 60;   // Minimum width per tab
        const maxTabWidth = 250;  // Maximum width per tab
        const idealTabWidth = 180; // Desired width when there are few tabs

        let tabWidth;
        if (tabs.length <= 5) {
            // When few tabs, use a more generous width
            tabWidth = Math.min(
                Math.max(idealTabWidth, availableWidth / tabs.length),
                maxTabWidth
            );
        } else {
            // When many tabs, use a more compact approach
            tabWidth = Math.max(
                minTabWidth,
                Math.min(
                    availableWidth / tabs.length,
                    maxTabWidth
                )
            );
        }

        tabs.forEach(tab => {
            const nameElement = tab.querySelector('.tab-name');

            // Reset any previous width constraints
            tab.style.width = '';
            nameElement.style.overflow = 'hidden';
            nameElement.style.textOverflow = 'ellipsis';
            nameElement.style.whiteSpace = 'nowrap';

            // Set the tab width
            tab.style.width = `${tabWidth}px`;

            // If the text is truncated, add a tooltip
            if (nameElement.scrollWidth > nameElement.clientWidth) {
                tab.title = nameElement.textContent;
            } else {
                tab.removeAttribute('title');
            }
        });
    }
}





class LivePreview {
    constructor(container, editor) {
        this.container = container;
        this.editor = editor;
        this.isActive = false;
        this.previewContainer = null;
        this.frame = null;
        this.changeListener = null;
        this.dragStartHandler = this.handleDragStart.bind(this);
        this.dragEndHandler = this.handleDragEnd.bind(this);
        this.init();
    }

    init() {
        const style = document.createElement('style');
        style.textContent = `
            .live-preview-container {
                position: absolute;
                top: 40px;
                left: var(--handle-width);
                right: 0;
                bottom: 0;
                background-color: var(--bg-primary);
                overflow: auto;
                display: none;
                pointer-events: none;
                z-index: 1;
            }

            .live-preview-container.active {
                pointer-events: auto;
            }

            .live-preview-container.dragging,
            .live-preview-container.dragging iframe {
                pointer-events: none !important;
                user-select: none !important;
            }

            .live-preview-frame {
                width: 100%;
                height: 100%;
                border: none;
                background-color: var(--bg-primary);
                pointer-events: auto;
            }

            .resize-handle-buffer {
                position: absolute;
                top: 0;
                left: calc(var(--handle-width) * -1);
                width: calc(var(--handle-width) * 2);
                height: 100%;
                z-index: 100;
                pointer-events: none;
            }
        `;
        document.head.appendChild(style);
    }

    handleDragStart(e) {
        const resizeHandle = document.querySelector('.resize-handle-container');
        if (resizeHandle && resizeHandle.contains(e.target)) {
            if (this.previewContainer) {
                this.previewContainer.classList.add('dragging');
            }
        }
    }

    handleDragEnd() {
        if (this.previewContainer) {
            this.previewContainer.classList.remove('dragging');
        }
    }

    createPreview() {
        this.previewContainer = document.createElement('div');
        this.previewContainer.className = 'live-preview-container';
        this.container.appendChild(this.previewContainer);

        const buffer = document.createElement('div');
        buffer.className = 'resize-handle-buffer';
        this.previewContainer.appendChild(buffer);

        this.frame = document.createElement('iframe');
        this.frame.className = 'live-preview-frame';
        this.previewContainer.appendChild(this.frame);

        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            this.changeListener = this.debounce(this.updatePreview.bind(this), 300);
            activeEditor.session.on('change', this.changeListener);
        }

        document.addEventListener('mousedown', this.dragStartHandler);
        document.addEventListener('mouseup', this.dragEndHandler);
    }

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    show() {
        this.isActive = true;
        this.createPreview();
        this.previewContainer.style.display = 'block';
        this.updatePreview();

        setTimeout(() => {
            if (this.previewContainer) {
                this.previewContainer.classList.add('active');
            }
        }, 100);
    }

    hide() {
        this.isActive = false;
        this.cleanup();
    }

    cleanup() {
        const activeEditor = this.editor.getActiveEditor();
        if (this.changeListener && activeEditor) {
            activeEditor.session.off('change', this.changeListener);
            this.changeListener = null;
        }

        document.removeEventListener('mousedown', this.dragStartHandler);
        document.removeEventListener('mouseup', this.dragEndHandler);

        if (this.previewContainer) {
            this.previewContainer.remove();
            this.previewContainer = null;
            this.frame = null;
        }
    }

    updatePreview() {
        if (!this.isActive || !this.frame) return;

        const activeEditor = this.editor.getActiveEditor();
        if (!activeEditor) return;

        const content = activeEditor.getValue();
        const frameDoc = this.frame.contentDocument || this.frame.contentWindow.document;

        frameDoc.open();

        const darkTheme = `
            <style>
                body {
                    margin: 0;
                    padding: 20px;
                    background-color: #1a1a1a;
                    color: #ffffff;
                    font-family: Arial, sans-serif;
                }
            </style>
        `;

        frameDoc.write(darkTheme + content);
        frameDoc.close();
    }
}





class TextEditor {
    static instance = null;

    constructor() {
        if (TextEditor.instance) {
            return TextEditor.instance;
        }

        this.currentFileHandle = null;
        this.tabManager = new TabManager(this);
        this.sidePane = new SidePane(this);
        this.settings = new Settings();

        TextEditor.instance = this;

        const initialTabId = this.tabManager.createNewTab();
        this.initEditor(initialTabId);

        this.setupGlobalKeyboardShortcuts();
        this.setupDropZone();
        this.setupSettingsWindow();
        this.addSettingsButton();
        this.updateStatusBarStyle();

        setTimeout(() => {
            this.getActiveEditor().focus();
        }, 100);
    }

    setupGlobalKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Handle Ctrl+S (or Cmd+S on Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                TextEditor.saveFile();
            }
        });
    }
    initEditor(tabId) {
        const editor = this.tabManager.getEditor(tabId);
        if (!editor) return;

        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/html");
        editor.session.setOption("useWorker", false);
        editor.setFontSize(15);
        editor.setOption("fontFamily", "Courier New, monospace");
        editor.session.setUseWrapMode(true);
        editor.setShowPrintMargin(false);

        editor.setOptions({
            enableBasicAutocompletion: true,
            enableSnippets: false,
            enableLiveAutocompletion: true,
            highlightActiveLine: true,
            highlightSelectedWord: true,
            showPrintMargin: false
        });

        this.setupEditorCommands(editor);
        this.setupSelectionFlash(editor);
    }

    setupSelectionFlash(editor) {
        editor.selection.on("changeSelection", () => {
            const selections = editor.container.querySelectorAll(".ace_marker-layer .ace_selection");
            selections.forEach(selection => {
                selection.style.transition = "opacity 0.25s ease-in-out";
                selection.style.opacity = "1";
                setTimeout(() => selection.style.opacity = "0.4", 0);
                setTimeout(() => selection.style.opacity = "1", 250);
                setTimeout(() => selection.style.opacity = "0.4", 500);
                setTimeout(() => {
                    selection.style.opacity = "1";
                    selection.style.transition = "";
                }, 750);
            });
        });
    }

    setupEditorCommands(editor) {
        editor.commands.removeCommand('save');
        editor.commands.removeCommand('saveAs');
        editor.commands.removeCommand('find');
        editor.commands.removeCommand('open');
        editor.commands.removeCommand('togglePane');
        editor.commands.removeCommand('newTab');
        editor.commands.removeCommand('closeTab');

        editor.commands.addCommand({
            name: 'find',
            bindKey: { win: 'Ctrl-F', mac: 'Command-F' },
            exec: (editor) => {
                ace.require("ace/ext/searchbox").Search(editor);
            }
        });

        editor.commands.addCommand({
            name: 'save',
            bindKey: { win: 'Ctrl-S', mac: 'Command-S' },
            exec: () => {
                TextEditor.saveFile();
            }
        });

        editor.commands.addCommand({
            name: 'saveAs',
            bindKey: { win: 'Ctrl-Shift-S', mac: 'Command-Shift-S' },
            exec: () => {
                TextEditor.saveFileAs();
            }
        });

        editor.commands.addCommand({
            name: 'open',
            bindKey: { win: 'Ctrl-O', mac: 'Command-O' },
            exec: () => {
                TextEditor.openFile();
            }
        });

        editor.commands.addCommand({
            name: 'togglePane',
            bindKey: { win: 'Ctrl-B', mac: 'Command-B' },
            exec: () => {
                TextEditor.toggleSidePane();
            }
        });

        editor.commands.addCommand({
            name: 'newTab',
            bindKey: { win: 'Ctrl-T', mac: 'Command-T' },
            exec: () => {
                this.tabManager.createNewTab();
            }
        });

        editor.commands.addCommand({
            name: 'closeTab',
            bindKey: { win: 'Ctrl-W', mac: 'Command-W' },
            exec: () => {
                const activeTabId = this.tabManager.activeTabId;
                if (activeTabId) {
                    this.tabManager.closeTab(activeTabId);
                }
            }
        });
    }
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) &&
                (e.key === 's' || e.key === 'o' || e.key === 'b' ||
                 e.key === 't' || e.key === 'w')) {
                e.preventDefault();
            }
        });

        const initialEditor = this.getActiveEditor();
        if (initialEditor) {
            this.setupEditorCommands(initialEditor);
        }

        this.tabManager.setupEditorShortcuts = this.setupEditorCommands.bind(this);
    }

    getActiveEditor() {
        return this.tabManager.getActiveEditor();
    }

    static updateFileName(name) {
        const currentFileElement = document.getElementById('current-file');
        if (currentFileElement) {
            currentFileElement.textContent = name || 'No file opened';
        }
    }

    static detectLanguage(filename) {
        const modelist = ace.require("ace/ext/modelist");
        const mode = modelist.getModeForPath(filename).mode;
        const editor = TextEditor.instance.getActiveEditor();
        if (editor) {
            editor.session.setMode(mode);
        }
        return mode;
    }

    static showStatusMessage(message, isSuccess = false) {
    const statusBar = document.getElementById('statusBar');

    // Clear any existing timers to prevent race conditions
    if (statusBar._hideTimer) {
      clearTimeout(statusBar._hideTimer);
      statusBar._hideTimer = null;
    }

    // Update the status message
    statusBar.textContent = message;

    // Remove the success class first to reset any existing animation
    statusBar.classList.remove('saved');

    // Force reflow to make sure the removal takes effect
    void statusBar.offsetWidth;

    if (isSuccess) {
      // Add the success class for styling
      statusBar.classList.add('saved');

      // Set a timer to remove the class after 2 seconds
      statusBar._hideTimer = setTimeout(() => {
        statusBar.classList.remove('saved');
        statusBar._hideTimer = null;
      }, 2000);
    }
  }

    static async saveFile() {
        try {
          const activeTabId = TextEditor.instance.tabManager.activeTabId;
          if (!activeTabId) {
            TextEditor.showStatusMessage('No active tab to save');
            return;
          }
    
          const tab = TextEditor.instance.tabManager.tabs.get(activeTabId);
          if (!tab) {
            TextEditor.showStatusMessage('Tab not found');
            return;
          }
    
          if (tab.customFileInfo) {
            const saved = await TextEditor.instance.tabManager.saveTabWithCustomFile(activeTabId);
            if (saved) {
              TextEditor.showStatusMessage('File saved successfully', true);
            }
            return;
          }
    
          const content = tab.editor.getValue();
    
          if (!tab.fileHandle) {
            await TextEditor.saveFileAs();
            return;
          }
    
          // Show an indicator that save operation is in progress
          TextEditor.showStatusMessage('Saving file...');
    
          // Use Promise to handle the save operation
          const writable = await tab.fileHandle.createWritable();
          await writable.write(content);
          await writable.close();
    
          // Mark the editor as clean after successful save
          tab.editor.session.getUndoManager().markClean();
          TextEditor.instance.tabManager.updateTabState(activeTabId);
    
          // Show success message only after the save is complete
          TextEditor.showStatusMessage('File saved successfully', true);
        } catch (err) {
          console.error('Failed to save file:', err);
          TextEditor.showStatusMessage('Error saving file');
        }
    }

    static async saveFileAs() {
        try {
          const activeTabId = TextEditor.instance.tabManager.activeTabId;
          if (!activeTabId) {
            TextEditor.showStatusMessage('No active tab to save');
            return;
          }
    
          const tab = TextEditor.instance.tabManager.tabs.get(activeTabId);
          if (!tab) {
            TextEditor.showStatusMessage('Tab not found');
            return;
          }
    
          const content = tab.editor.getValue();
    
          const options = {
            suggestedName: tab.name || 'untitled.txt',
            types: [{
              description: 'Text Files',
              accept: {
                'text/plain': [
                  '.txt', '.js', '.py', '.html', '.css',
                  '.json', '.xml', '.md', '.ts', '.php',
                  '.rb', '.go', '.sql'
                ],
              },
            }]
          };
    
          const startIn = TextEditor.instance.settings.getEffectiveStartIn();
          if (startIn) options.startIn = startIn;
    
          // Show an indicator that we're waiting for user input
          TextEditor.showStatusMessage('Waiting for save location...');
    
          const handle = await window.showSaveFilePicker(options);
    
          // Show indicator that save is in progress
          TextEditor.showStatusMessage('Saving file...');
    
          const writable = await handle.createWritable();
          await writable.write(content);
          await writable.close();
    
          TextEditor.instance.tabManager.setFileHandle(activeTabId, handle);
          TextEditor.detectLanguage(handle.name);
          tab.editor.session.getUndoManager().markClean();
          TextEditor.instance.tabManager.updateTabState(activeTabId);
          TextEditor.instance.settings.setLastDirHandle(handle);
    
          // Show success only after everything is complete
          TextEditor.showStatusMessage('File saved successfully', true);
        } catch (err) {
          if (err.name !== 'AbortError') {
            console.error('Failed to save file as:', err);
            TextEditor.showStatusMessage('Error saving file');
          } else {
            // User canceled the save dialog
            TextEditor.showStatusMessage('Save canceled');
          }
        }
    }


    static async openFile() {
        try {
            const options = {
                types: [{
                    description: 'Text Files',
                    accept: {
                        'text/plain': [
                            '.txt', '.js', '.py', '.html', '.css',
                            '.json', '.xml', '.md', '.ts', '.php',
                            '.rb', '.go', '.sql'
                        ],
                    },
                }]
            };

            const startIn = TextEditor.instance.settings.getEffectiveStartIn();
            if (startIn) options.startIn = startIn;

            const [fileHandle] = await window.showOpenFilePicker(options);
            const file = await fileHandle.getFile();
            const content = await file.text();

            const untitledTabId = TextEditor.instance.tabManager.hasUntitledUnmodifiedTab();
            let tabId;

            if (untitledTabId) {
                const tab = TextEditor.instance.tabManager.tabs.get(untitledTabId);
                tab.fileHandle = fileHandle;
                TextEditor.instance.tabManager.updateTabName(untitledTabId, fileHandle.name);
                tab.editor.setValue(content, -1);
                tab.editor.session.setMode(TextEditor.detectLanguage(file.name));
                tab.editor.session.getUndoManager().reset();
                tab.editor.session.getUndoManager().markClean();
                TextEditor.instance.tabManager.updateTabState(untitledTabId);
                tabId = untitledTabId;
            } else {
                tabId = TextEditor.instance.tabManager.createNewTab(fileHandle, content);
                TextEditor.instance.initEditor(tabId);
            }

            TextEditor.instance.settings.setLastDirHandle(fileHandle);
            TextEditor.instance.tabManager.activateTab(tabId);
            TextEditor.instance.getActiveEditor().focus();
        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error('Failed to open file:', err);
                TextEditor.showStatusMessage('Error opening file');
            }
        }
    }

    static toggleWordWrap() {
        const editor = TextEditor.instance.getActiveEditor();
        if (!editor) return;
        const newState = !editor.session.getUseWrapMode();
        editor.session.setUseWrapMode(newState);

        const wrapButton = document.querySelector('[data-tooltip="Toggle Word Wrap"]');
        if (wrapButton) {
            wrapButton.classList.toggle('active', newState);
        }
    }

    static toggleSidePane() {
        TextEditor.instance.sidePane.toggle();
    }

    setupDropZone() {
    // Set up the entire document as a drop zone
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      document.body.classList.add('drag-over');
    });

    document.addEventListener('dragleave', (e) => {
      if (e.target === document.documentElement) {
        document.body.classList.remove('drag-over');
      }
    });

    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      document.body.classList.remove('drag-over');

      if (e.dataTransfer.files.length > 0) {
        const files = Array.from(e.dataTransfer.files);
        for (const file of files) {
          try {
            // Open each file in its own tab without asking for save permission
            await this.openFileFromFileObject(file);
          } catch (err) {
            console.error('Error opening file:', err);
            TextEditor.showStatusMessage('Error opening file: ' + err.message, 'error');
          }
        }
      }
    });

    // Add a style for drag-over effect
    const style = document.createElement('style');
    style.textContent = `
      body.drag-over::after {
        content: 'Drop files to open';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        font-weight: bold;
        z-index: 9999;
        pointer-events: none;
      }
    `;
    document.head.appendChild(style);
  }

    async convertFileToHandle(file) {
        // Check if the File System Access API is available
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: file.name,
              types: [{
                description: 'Text Files',
                accept: {
                  'text/plain': ['.txt', '.js', '.py', '.html', '.css',
                                '.json', '.xml', '.md', '.ts', '.php',
                                '.rb', '.go', '.sql'],
                },
              }],
            });
    
            const content = await file.text();
    
            const writable = await handle.createWritable();
            await writable.write(content);
            await writable.close();
    
            return handle;
          } catch (err) {
            if (err.name === 'AbortError') {
              // User cancelled the save dialog, fall back to File object
              return null;
            }
            throw err;
          }
        }
        return null;
    }

    async openFileFromHandle(fileHandle) {
        try {
          const file = await fileHandle.getFile();
          const content = await file.text();
    
          const untitledTabId = this.tabManager.hasUntitledUnmodifiedTab();
          let tabId;
    
          if (untitledTabId) {
            const tab = this.tabManager.tabs.get(untitledTabId);
            tab.fileHandle = fileHandle;
            this.tabManager.updateTabName(untitledTabId, fileHandle.name);
            tab.editor.setValue(content, -1);
            tab.editor.session.setMode(TextEditor.detectLanguage(file.name));
            tab.editor.session.getUndoManager().reset();
            tab.editor.session.getUndoManager().markClean();
            this.tabManager.updateTabState(untitledTabId);
            tabId = untitledTabId;
          } else {
            tabId = this.tabManager.createNewTab(fileHandle, content);
            this.initEditor(tabId);
          }
    
          this.tabManager.activateTab(tabId);
          this.getActiveEditor().focus();
          TextEditor.showStatusMessage(`File ${fileHandle.name} opened`, 'saved');
        } catch (err) {
          console.error('Failed to open file:', err);
          TextEditor.showStatusMessage('Error opening file', 'error');
        }
    }

    async openFileFromFileObject(file) {
        try {
          const content = await file.text();
    
          // Always create a new tab for each dropped file
          const tabId = this.tabManager.createNewTab(null, content);
          this.tabManager.updateTabName(tabId, file.name);
          this.initEditor(tabId);
    
          // Set the correct language mode based on file extension
          const editor = this.tabManager.getEditor(tabId);
          if (editor) {
            editor.session.setMode(TextEditor.detectLanguage(file.name));
          }
    
          this.tabManager.activateTab(tabId);
          TextEditor.showStatusMessage(`File ${file.name} opened`, 'saved');
    
          // Create a custom file info object since we don't have a real FileSystemFileHandle
          const customFileInfo = {
            name: file.name,
            isCustom: true,
            content: content,
            lastModified: file.lastModified
          };
    
          // Store this custom file info in the tab
          const tab = this.tabManager.tabs.get(tabId);
          if (tab) {
            tab.customFileInfo = customFileInfo;
          }
        } catch (err) {
          console.error('Failed to open file:', err);
          TextEditor.showStatusMessage('Error opening file', 'error');
        }
    }

    addSettingsButton() {
        const toolbarButtons = document.querySelector('.toolbar-buttons');
        const wrapButton = document.querySelector('[data-tooltip="Toggle Word Wrap"]');

        const settingsButton = document.createElement('button');
        settingsButton.className = 'toolbar-button tooltip';
        settingsButton.setAttribute('data-tooltip', 'Settings');
        settingsButton.innerHTML = '<i class="fas fa-cog"></i>';
        settingsButton.onclick = () => this.toggleSettingsWindow();

        wrapButton.insertAdjacentElement('afterend', settingsButton);
    }

    setupSettingsWindow() {
        this.settingsWindow = document.createElement('div');
        this.settingsWindow.className = 'settings-window';
        this.settingsWindow.innerHTML = `
            <div class="settings-header">
                <h3>Settings</h3>
                <button class="settings-close">✕</button>
            </div>
            <div class="settings-content">
                <div class="settings-field">
                    <label>Storage Directory</label>
                    <div class="settings-input-container">
                        <input type="text" id="storageDirInput" value="${this.settings.getStorageDirectory()}">
                        <button class="browse-button" id="browseDir">Browse</button>
                    </div>
                </div>
                <div class="settings-toggle">
                    <input type="checkbox" id="useStorageDir" ${this.settings.getUseStorageDirectory() ? 'checked' : ''}>
                    <label for="useStorageDir">Use Storage Directory (unchecked uses last accessed location)</label>
                </div>
            
                <div class="settings-section">
                    <h4>Downloads</h4>
                    <div class="download-container">
                        <button id="downloadExtension" class="download-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Download AICodeBridge Chrome Extension (unpacked)
                        </button>
                        <br> 
                        <u>Instructions:</u>
                        <br>
                        1. - Download the zip file, extract it.
                        <br>
                        2. - In google chrome go to chrome://extensions/ and enable developer mode.
                        <br>
                        3. - Click load unpacked and select the extracted folder.
                    </div>
                </div>
            
                <div class="settings-buttons">
                    <button class="settings-button" id="settingsSave">Save</button>
                    <button class="settings-button" id="settingsCancel">Cancel</button>
                </div>
            </div>
        `;
        document.body.appendChild(this.settingsWindow);
        this.settingsWindow.querySelector('#settingsSave').addEventListener('click', () => this.saveSettings());
        this.settingsWindow.querySelector('#settingsCancel').addEventListener('click', () => this.toggleSettingsWindow());
        this.settingsWindow.querySelector('.settings-close').addEventListener('click', () => this.toggleSettingsWindow());
        this.settingsWindow.querySelector('#browseDir').addEventListener('click', () => this.browseDirectory());
        this.settingsWindow.querySelector('#storageDirInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') this.saveSettings();
        });
        this.settingsWindow.querySelector('#useStorageDir').addEventListener('change', (e) => {
            this.settings.setUseStorageDirectory(e.target.checked);
        });
        

        this.settingsWindow.querySelector('#downloadExtension').addEventListener('click', () => {
            this.downloadExtension('./AICodeBridgeExtension.zip');
        });
        
        this.makeDraggable(this.settingsWindow);

        this.centerSettingsWindow();
    }


    downloadExtension(filePath) {
        const link = document.createElement('a');
        link.href = filePath;
        link.download = 'AICodeBridgeExtension.crx';
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        
        setTimeout(() => {
            document.body.removeChild(link);
        }, 100);
    }

    toggleSettingsWindow() {
        const isVisible = this.settingsWindow.classList.contains('visible');
        if (!isVisible) {
            this.settingsWindow.querySelector('#storageDirInput').value = this.settings.getStorageDirectory();
            this.settingsWindow.querySelector('#useStorageDir').checked = this.settings.getUseStorageDirectory();
            this.centerSettingsWindow();
        }
        this.settingsWindow.classList.toggle('visible');
    }

    saveSettings() {
        const dirInput = this.settingsWindow.querySelector('#storageDirInput').value;
        this.settings.setStorageDirectory(dirInput);
        this.toggleSettingsWindow();
        TextEditor.showStatusMessage('Settings saved', true);
    }

    async browseDirectory() {
        try {
            const dirHandle = await window.showDirectoryPicker();
            this.settings.setDirHandle(dirHandle);
            this.settingsWindow.querySelector('#storageDirInput').value = dirHandle.name;
        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error('Failed to select directory:', err);
                TextEditor.showStatusMessage('Error selecting directory');
            }
        }
    }

    makeDraggable(element) {
        const header = element.querySelector('.settings-header');
        let isDragging = false;
        let offsetX, offsetY;

        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - element.getBoundingClientRect().left;
            offsetY = e.clientY - element.getBoundingClientRect().top;
            header.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                const newLeft = e.clientX - offsetX;
                const newTop = e.clientY - offsetY;
                const maxLeft = window.innerWidth - element.offsetWidth;
                const maxTop = window.innerHeight - element.offsetHeight;
                element.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
                element.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
                element.style.transform = 'none';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                header.style.cursor = 'move';
            }
        });
    }

    centerSettingsWindow() {
        const win = this.settingsWindow;
        if (!win.classList.contains('visible')) {
            requestAnimationFrame(() => {
                const left = (window.innerWidth - win.offsetWidth) / 2;
                const top = (window.innerHeight - win.offsetHeight) / 2;
                win.style.left = `${left}px`;
                win.style.top = `${top}px`;
                win.style.transform = 'none';
            });
        } else {
            const left = (window.innerWidth - win.offsetWidth) / 2;
            const top = (window.innerHeight - win.offsetHeight) / 2;
            win.style.left = `${left}px`;
            win.style.top = `${top}px`;
            win.style.transform = 'none';
        }
    }

    updateStatusBarStyle() {
        const styleId = 'status-bar-styles';
        let styleEl = document.getElementById(styleId);
    
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
    
        styleEl.textContent = `
          .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 28px;
            background-color: rgba(35, 35, 35, 0.7);  /* Darker color and more transparent */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(100%);
            z-index: 20;
            pointer-events: none;
          }
    
          .status-bar.saved {
            background-color: rgba(39, 174, 96, 0.75);  /* Darker green and slightly more transparent */
            color: white;
            opacity: 1;
            transform: translateY(0);
          }
    
          /* Reposition status bar to only cover the editor area */
          .workspace {
            position: relative;
          }
    
          .editor-container {
            position: relative;
          }
    
          #statusBar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            right: auto;
          }
        `;
    
        const statusBar = document.getElementById('statusBar');
        const editorContainer = document.querySelector('.editor-container');
    
        if (statusBar && editorContainer) {
          if (statusBar.parentElement !== editorContainer) {
            statusBar.remove();
            editorContainer.appendChild(statusBar);
          }
        }
      }
    }




    class AINavigationManager {
      constructor(container, options = {}) {
        console.log('[AINavigationManager] Initializing...');
        this.container = container;
        this.navContainer = null;
        this.counterElement = null;
        this.timeAgoElement = null;
        this.sliderElement = null;
        this.topNavContainer = null;
        this.topCounterElement = null;
        this.topTimeAgoElement = null;
        this.topSliderElement = null;
    
        this.currentIndex = 0;
        this.totalItems = 0;
        this.autoScrollEnabled = options.autoScrollEnabled ?? true;
        this.jumpToLatestEnabled = options.jumpToLatestEnabled ?? true;
    
        this.onPrev = options.onPrev || (() => {});
        this.onNext = options.onNext || (() => {});
        this.onClear = options.onClear || (() => {});
        this.onDelete = options.onDelete || (() => {});
        this.onSliderChange = options.onSliderChange || (() => {});
        this.onRefresh = options.onRefresh || (() => {});
        this.onJumpToLatestToggle = options.onJumpToLatestToggle || (() => {});
        this.onAutoScrollToggle = options.onAutoScrollToggle || (() => {});
    
        this.init();
        console.log('[AINavigationManager] Initialization complete');
    }
  
    init() {
        this.createNavPane();
        this.createTopNavPane();
        this.addEventListeners();
        this.addStyles();
        this.startTimeAgoUpdater();
        this.updateScrollToggleButtonState();
        this.updateJumpToggleButtonState();
    }
  
    createNavPane() {
        this.navContainer = this.container.querySelector('.ai-nav-pane');
        if (!this.navContainer) {
          this.navContainer = document.createElement('div');
          this.navContainer.className = 'ai-nav-pane';
          this.container.appendChild(this.navContainer);
        }
        
        this.navContainer.innerHTML = `
          <button class="ai-nav-button ai-nav-left"><i class="fas fa-chevron-left"></i></button>
          <button class="ai-nav-button ai-nav-right"><i class="fas fa-chevron-right"></i></button>
          <span class="block-counter">0 / 0</span>
          <input type="range" class="ai-slider" min="0" max="0" value="0">
          <span class="time-ago">N/A</span>
          <button class="ai-nav-button ai-jump-toggle" title="Toggle Jump to Latest">→</button>
          <button class="ai-nav-button ai-scroll-toggle" title="Toggle Vertical Scroll">↓</button>
          <button class="ai-nav-button ai-refresh" title="Refresh Code Blocks"><i class="fas fa-sync-alt"></i></button>
          <button class="ai-nav-button ai-delete" title="Delete Current Chunk">X</button>
          <button class="ai-nav-button ai-clear-all" title="Clear All Chunks">Clear</button>
        `;
        
        this.counterElement = this.navContainer.querySelector('.block-counter');
        this.timeAgoElement = this.navContainer.querySelector('.time-ago');
        this.sliderElement = this.navContainer.querySelector('.ai-slider');
    }
  
    addEventListeners() {
        const prevButton = this.navContainer.querySelector('.ai-nav-button.ai-nav-left');
        const nextButton = this.navContainer.querySelector('.ai-nav-button.ai-nav-right');
        const deleteButton = this.navContainer.querySelector('.ai-nav-button.ai-delete');
        const clearButton = this.navContainer.querySelector('.ai-nav-button.ai-clear-all');
        const scrollToggleButton = this.navContainer.querySelector('.ai-nav-button.ai-scroll-toggle');
        const jumpToggleButton = this.navContainer.querySelector('.ai-nav-button.ai-jump-toggle');
        const refreshButton = this.navContainer.querySelector('.ai-nav-button.ai-refresh');
    
        prevButton.addEventListener('click', () => {
          if (this.currentIndex > 0) {
            this.currentIndex--;
            this.onPrev(this.currentIndex);
            this.updateNavControls();
          }
        });
    
        nextButton.addEventListener('click', () => {
          if (this.currentIndex < this.totalItems - 1) {
            this.currentIndex++;
            this.onNext(this.currentIndex);
            this.updateNavControls();
          }
        });
    
        clearButton.addEventListener('click', () => {
          this.onClear();
          this.updateNavControls();
        });
    
        deleteButton.addEventListener('click', () => {
          this.onDelete(this.currentIndex);
          this.updateNavControls();
        });
    
        scrollToggleButton.addEventListener('click', () => {
          this.autoScrollEnabled = !this.autoScrollEnabled;
          this.updateScrollToggleButtonState();
          this.onAutoScrollToggle(this.autoScrollEnabled);
        });
    
        jumpToggleButton.addEventListener('click', () => {
          this.jumpToLatestEnabled = !this.jumpToLatestEnabled;
          this.updateJumpToggleButtonState();
          this.onJumpToLatestToggle(this.jumpToLatestEnabled);
        });
    
        refreshButton.addEventListener('click', () => {
          this.onRefresh();
        });
    
        this.sliderElement.addEventListener('input', () => {
          this.currentIndex = parseInt(this.sliderElement.value, 10);
          this.onSliderChange(this.currentIndex);
          this.updateNavControls();
        });
    
        this.sliderElement.addEventListener('wheel', (event) => {
          event.preventDefault();
          const delta = event.deltaY > 0 ? 1 : -1;
          const newIndex = Math.max(0, Math.min(this.currentIndex + delta, this.totalItems - 1));
          if (newIndex !== this.currentIndex) {
            this.currentIndex = newIndex;
            this.sliderElement.value = this.currentIndex;
            this.onSliderChange(this.currentIndex);
            this.updateNavControls();
          }
        });
    
        // Top nav event listeners - duplicate functionality
        const topPrevButton = this.topNavContainer.querySelector('.ai-nav-button.ai-nav-left');
        const topNextButton = this.topNavContainer.querySelector('.ai-nav-button.ai-nav-right');
        const topDeleteButton = this.topNavContainer.querySelector('.ai-nav-button.ai-delete');
        const topClearButton = this.topNavContainer.querySelector('.ai-nav-button.ai-clear-all');
        const topScrollToggleButton = this.topNavContainer.querySelector('.ai-nav-button.ai-scroll-toggle');
        const topJumpToggleButton = this.topNavContainer.querySelector('.ai-nav-button.ai-jump-toggle');
        const topRefreshButton = this.topNavContainer.querySelector('.ai-nav-button.ai-refresh');
    
        topPrevButton.addEventListener('click', () => {
          if (this.currentIndex > 0) {
            this.currentIndex--;
            this.onPrev(this.currentIndex);
            this.updateNavControls();
          }
        });
    
        topNextButton.addEventListener('click', () => {
          if (this.currentIndex < this.totalItems - 1) {
            this.currentIndex++;
            this.onNext(this.currentIndex);
            this.updateNavControls();
          }
        });
    
        topClearButton.addEventListener('click', () => {
          this.onClear();
          this.updateNavControls();
        });
    
        topDeleteButton.addEventListener('click', () => {
          this.onDelete(this.currentIndex);
          this.updateNavControls();
        });
    
        topScrollToggleButton.addEventListener('click', () => {
          this.autoScrollEnabled = !this.autoScrollEnabled;
          this.updateScrollToggleButtonState();
          this.onAutoScrollToggle(this.autoScrollEnabled);
        });
    
        topJumpToggleButton.addEventListener('click', () => {
          this.jumpToLatestEnabled = !this.jumpToLatestEnabled;
          this.updateJumpToggleButtonState();
          this.onJumpToLatestToggle(this.jumpToLatestEnabled);
        });
    
        topRefreshButton.addEventListener('click', () => {
          this.onRefresh();
        });
    
        this.topSliderElement.addEventListener('input', () => {
          this.currentIndex = parseInt(this.topSliderElement.value, 10);
          this.onSliderChange(this.currentIndex);
          this.updateNavControls();
        });
    
        this.topSliderElement.addEventListener('wheel', (event) => {
          event.preventDefault();
          const delta = event.deltaY > 0 ? 1 : -1;
          const newIndex = Math.max(0, Math.min(this.currentIndex + delta, this.totalItems - 1));
          if (newIndex !== this.currentIndex) {
            this.currentIndex = newIndex;
            this.topSliderElement.value = this.currentIndex;
            this.onSliderChange(this.currentIndex);
            this.updateNavControls();
          }
        });
    }
  
    updateScrollToggleButtonState() {
        if (this.navContainer) {
          const button = this.navContainer.querySelector('.ai-nav-button.ai-scroll-toggle');
          if (button) {
            button.classList.remove('active', 'inactive');
    
            if (this.autoScrollEnabled) {
              button.classList.add('active');
              button.style.backgroundColor = '#4CAF50';
              button.textContent = '↓';
              button.title = "Vertical Scroll Enabled (Click to Disable)";
            } else {
              button.classList.add('inactive');
              button.style.backgroundColor = '#555';
              button.textContent = '↑';
              button.title = "Vertical Scroll Disabled (Click to Enable)";
            }
          }
        }
    
        if (this.topNavContainer) {
          const topButton = this.topNavContainer.querySelector('.ai-nav-button.ai-scroll-toggle');
          if (topButton) {
            topButton.classList.remove('active', 'inactive');
    
            if (this.autoScrollEnabled) {
              topButton.classList.add('active');
              topButton.style.backgroundColor = '#4CAF50';
              topButton.textContent = '↓';
              topButton.title = "Vertical Scroll Enabled (Click to Disable)";
            } else {
              topButton.classList.add('inactive');
              topButton.style.backgroundColor = '#555';
              topButton.textContent = '↑';
              topButton.title = "Vertical Scroll Disabled (Click to Enable)";
            }
          }
        }
    }
  
  updateJumpToggleButtonState() {
    if (this.navContainer) {
      const button = this.navContainer.querySelector('.ai-nav-button.ai-jump-toggle');
      if (button) {
        if (this.jumpToLatestEnabled) {
          button.classList.add('active');
          button.style.backgroundColor = '#4CAF50';
          button.textContent = '→';
          button.title = "Jump to Latest Enabled (Click to Disable)";
        } else {
          button.classList.remove('active');
          button.style.backgroundColor = '#555';
          button.textContent = '←';
          button.title = "Jump to Latest Disabled (Click to Enable)";
        }
      }
    }

    if (this.topNavContainer) {
      const topButton = this.topNavContainer.querySelector('.ai-nav-button.ai-jump-toggle');
      if (topButton) {
        if (this.jumpToLatestEnabled) {
          topButton.classList.add('active');
          topButton.style.backgroundColor = '#4CAF50';
          topButton.textContent = '→';
          topButton.title = "Jump to Latest Enabled (Click to Disable)";
        } else {
          topButton.classList.remove('active');
          topButton.style.backgroundColor = '#555';
          topButton.textContent = '←';
          topButton.title = "Jump to Latest Disabled (Click to Enable)";
        }
      }
    }
  }
  
  updateNavControls(options = {}) {
    const { currentIndex, totalItems, timestamp } = {
      currentIndex: options.currentIndex !== undefined ? options.currentIndex : this.currentIndex,
      totalItems: options.totalItems !== undefined ? options.totalItems : this.totalItems,
      timestamp: options.timestamp
    };

    this.currentIndex = currentIndex;
    this.totalItems = totalItems;

    // Update bottom nav controls
    const prevButton = this.navContainer.querySelector('.ai-nav-button.ai-nav-left');
    const nextButton = this.navContainer.querySelector('.ai-nav-button.ai-nav-right');
    const clearButton = this.navContainer.querySelector('.ai-nav-button.ai-clear-all');
    const deleteButton = this.navContainer.querySelector('.ai-nav-button.ai-delete');

    // Update top nav controls
    const topPrevButton = this.topNavContainer.querySelector('.ai-nav-button.ai-nav-left');
    const topNextButton = this.topNavContainer.querySelector('.ai-nav-button.ai-nav-right');
    const topClearButton = this.topNavContainer.querySelector('.ai-nav-button.ai-clear-all');
    const topDeleteButton = this.topNavContainer.querySelector('.ai-nav-button.ai-delete');

    const currentPosition = totalItems > 0 ? this.currentIndex + 1 : 0;

    // Update bottom nav buttons
    prevButton.disabled = totalItems <= 1 || this.currentIndex <= 0;
    nextButton.disabled = totalItems <= 1 || this.currentIndex >= totalItems - 1;
    clearButton.disabled = totalItems === 0;
    deleteButton.disabled = totalItems === 0 || this.currentIndex < 0;

    // Update top nav buttons
    topPrevButton.disabled = totalItems <= 1 || this.currentIndex <= 0;
    topNextButton.disabled = totalItems <= 1 || this.currentIndex >= totalItems - 1;
    topClearButton.disabled = totalItems === 0;
    topDeleteButton.disabled = totalItems === 0 || this.currentIndex < 0;

    // Update counters and sliders
    this.counterElement.textContent = `${currentPosition} / ${totalItems}`;
    this.sliderElement.max = totalItems > 0 ? totalItems - 1 : 0;
    this.sliderElement.value = this.currentIndex;

    this.topCounterElement.textContent = `${currentPosition} / ${totalItems}`;
    this.topSliderElement.max = totalItems > 0 ? totalItems - 1 : 0;
    this.topSliderElement.value = this.currentIndex;

    // Update timestamps
    if (timestamp) {
      this.timeAgoElement.textContent = this.getTimeAgo(timestamp);
      this.topTimeAgoElement.textContent = this.getTimeAgo(timestamp);
    }

    this.updateScrollToggleButtonState();
    this.updateJumpToggleButtonState();
  }
  
  addStyles() {
    const styleId = 'ai-navigation-manager-styles';
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
    .ai-nav-pane {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 3px;
      background-color: var(--bg-secondary, #2a2a2a);
      border-bottom: 1px solid var(--border-color, #444);
      overflow: visible; /* Ensure content isn't clipped */
    }

    .ai-nav-pane.ai-nav-pane-top {
      border-bottom: 1px solid var(--border-color, #444);
      border-top: none;
      position: relative;
      top: -5px; /* Move up by 10px */
      margin-bottom: -5px; /* Compensate for the negative top */
      padding: 8px 3px 5px 15px; /* Increased top padding */
      z-index: 10;
      overflow: visible; /* Ensure content isn't clipped */
      
    }

    /* Ensure buttons in top nav aren't cut off */
    .ai-nav-pane.ai-nav-pane-top .ai-nav-button {
      position: relative;
      top: 1px; /* Shift buttons down slightly */
    }

    .ai-nav-button {
      background-color: #3a3a3a;
      color: #d0d0d0;
      border: 1px solid #555;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin: 0 2px;
      font-size: 12px;
      transition: background-color 0.2s ease;
    }

    .ai-nav-button:hover {
      background-color: #4f4f4f;
    }

    .ai-nav-button:disabled {
      background-color: #2a2a2a;
      color: #888;
      cursor: not-allowed;
    }

    .ai-nav-button.ai-nav-left, .ai-nav-button.ai-nav-right {
      background-color: #3a3a3a;
      color: #e0e0e0;
      padding: 4px 10px;
      font-size: 14px;
    }

    .ai-nav-button.ai-jump-toggle {
      background-color: #4CAF50;
      padding: 4px 8px;
    }

    .ai-nav-button.ai-jump-toggle:hover {
      background-color: #388e3c;
    }

    .ai-nav-button.ai-scroll-toggle {
      background-color: #4CAF50;
      padding: 4px 8px;
    }

    .ai-nav-button.ai-scroll-toggle:hover {
      background-color: #388e3c;
    }

    .block-counter {
      color: var(--text-primary, #e0e0e0);
      font-size: 10px;
      padding: 0 3px;
      min-width: 30px;
      text-align: center;
    }

    .time-ago {
      color: var(--text-secondary, #a0a0a0);
      font-size: 10px;
      padding: 0 3px;
      min-width: 30px;
      text-align: center;
    }

    .ai-slider {
      flex-grow: 1;
      margin: 0 5px;
      -webkit-appearance: none;
      height: 4px;
      background: #444;
      border-radius: 4px;
      outline: none;
      min-width: 10px;
    }

    .ai-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--accent, #7e57c2);
      border-radius: 50%;
      cursor: pointer;
    }
    `;

    document.head.appendChild(style);
  }
  
  getTimeAgo(timestamp) {
    const now = Date.now();
    const secondsAgo = Math.floor((now - timestamp) / 1000);
    
    if (secondsAgo < 60) return `${secondsAgo}s ago`;
    if (secondsAgo < 3600) return `${Math.floor(secondsAgo / 60)}m ago`;
    if (secondsAgo < 86400) return `${Math.floor(secondsAgo / 3600)}h ago`;
    return `${Math.floor(secondsAgo / 86400)}d ago`;
  }
  
  startTimeAgoUpdater() {
    this.timeAgoUpdateInterval = setInterval(() => {
      if (this.lastTimestamp) {
        this.timeAgoElement.textContent = this.getTimeAgo(this.lastTimestamp);
        this.topTimeAgoElement.textContent = this.getTimeAgo(this.lastTimestamp);
      }
    }, 10000); // Update every 10 seconds
  }
  
  setCurrentTimestamp(timestamp) {
    this.lastTimestamp = timestamp;
    if (timestamp) {
      this.timeAgoElement.textContent = this.getTimeAgo(timestamp);
      this.topTimeAgoElement.textContent = this.getTimeAgo(timestamp);
    }
  }
  
  showStatusMessage(message, className) {
    const statusBar = document.getElementById('statusBar');
    if (statusBar) {
      statusBar.textContent = message;
      statusBar.classList.remove('saved', 'copied', 'replaced', 'error', 'refreshing');
      if (className) statusBar.classList.add(className);
      setTimeout(() => statusBar.classList.remove(className), 2000);
    }
  }
  
  scrollToBottom(messageDisplay, codeViewer) {
    if (messageDisplay) {
      const scrollToTarget = () => {
        messageDisplay.scrollTop = messageDisplay.scrollHeight;
        this.scrollAllEditorsToBottom(codeViewer);
      };

      scrollToTarget();
      setTimeout(scrollToTarget, 50);
      requestAnimationFrame(() => {
        scrollToTarget();
      });
    }
  }
  
  isAtBottom(messageDisplay) {
    if (!messageDisplay) return true;
    const tolerance = 50;
    const scrollPosition = messageDisplay.scrollTop + messageDisplay.clientHeight;
    const scrollHeight = messageDisplay.scrollHeight;
    return scrollPosition >= scrollHeight - tolerance;
  }
  
  scrollAllEditorsToBottom(codeViewer) {
    if (!codeViewer || !codeViewer.editors) return;
    codeViewer.editors.forEach((editorInfo) => {
      if (editorInfo && editorInfo.editor) {
        requestAnimationFrame(() => {
          try {
            const editor = editorInfo.editor;
            const lineCount = editor.session.getLength();
            editor.scrollToLine(lineCount - 1, true, true, () => {});
          } catch (e) {
            console.error('[AINavigationManager] Error scrolling editor:', e);
          }
        });
      }
    });
  }
  
  hashString(str) {
    if (!str || typeof str !== 'string') {
      console.error('[AINavigationManager] Invalid input to hashString:', str);
      return 'invalid-' + Date.now();
    }

    try {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
      }
      return hash.toString(16);
    } catch (error) {
      console.error('[AINavigationManager] Error in hashString:', error);
      return 'error-' + Date.now();
    }
  }
  
  isContinuation(previousMessage, newMessage) {
    if (!previousMessage || !newMessage) return false;
    if (newMessage.length <= previousMessage.length) return false;

    try {
      if (previousMessage.startsWith('<!DOCTYPE html>') && newMessage.startsWith('<!DOCTYPE html>')) {
        const checkLength = Math.min(1000, previousMessage.length);
        return newMessage.substring(0, checkLength) === previousMessage.substring(0, checkLength);
      }
      const checkLength = Math.min(100, previousMessage.length);
      return newMessage.substring(0, checkLength) === previousMessage.substring(0, checkLength);
    } catch (error) {
      console.error('[AINavigationManager] Error in isContinuation:', error);
      return false;
    }
  }
  
  isSimilarContent(content1, content2) {
    const isHtml1 = content1 && typeof content1 === 'string' &&
                   (content1.startsWith('<!DOCTYPE html>') || content1.startsWith('<html'));
    const isHtml2 = content2 && typeof content2 === 'string' &&
                   (content2.startsWith('<!DOCTYPE html>') || content2.startsWith('<html'));

    if (isHtml1 && isHtml2) {
      const normalizedHtml1 = this.normalizeHtmlForComparison(content1);
      const normalizedHtml2 = this.normalizeHtmlForComparison(content2);
      const similarity = this.calculateSimilarity(normalizedHtml1, normalizedHtml2);
      const isSimilar = similarity > 0.75;
      if (superiority > 0.5) {
        //console.log(`[AINavigationManager] HTML similarity: ${similarity.toFixed(2)}, similar: ${isSimilar}`);
      }
      return isSimilar;
    }

    if (content1.length < 50 || content2.length < 50) {
      return content1 === content2;
    }

    const similarity = this.calculateSimilarity(content1, content2);
    return similarity > 0.9;
  }
  
  calculateSimilarity(string1, string2) {
    if (string1 === string2) return 1.0;
    if (!string1 || !string2) return 0;

    if (string1.length > string2.length * 2 || string2.length > string1.length * 2) {
      if (string1.includes(string2)) return string2.length / string1.length;
      if (string2.includes(string1)) return string1.length / string2.length;
    }

    if (string1.length < 500 && string2.length < 500) {
      const set1 = new Set(string1);
      const set2 = new Set(string2);
      const intersection = new Set([...set1].filter(x => set2.has(x)));
      const union = new Set([...set1, ...set2]);
      return intersection.size / union.size;
    }

    const words1 = string1.split(/\s+/).filter(Boolean);
    const words2 = string2.split(/\s+/).filter(Boolean);
    const set1 = new Set(words1);
    const set2 = new Set(words2);
    const intersection = new Set([...set1].filter(x => set2.has(x)));
    const union = new Set([...set1, ...set2]);
    return intersection.size / union.size;
  }
  
  normalizeHtmlForComparison(html) {
    if (!html || typeof html !== 'string') return '';
    if (!html.startsWith('<!DOCTYPE html>') && !html.startsWith('<html')) return html;

    try {
      let normalized = html.replace(/<!DOCTYPE[^>]*>/i, '')
                          .replace(/<!--[\s\S]*?-->/g, '');
      const bodyMatch = normalized.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      if (bodyMatch) {
        normalized = bodyMatch[1].trim();
      }
      normalized = normalized.replace(/\s+/g, ' ')
                            .replace(/>\s+</g, '><')
                            .trim();
      normalized = normalized.replace(/\s(id|class|style|data-\w+)="[^"]*"/g, '');
      return normalized;
    } catch (e) {
      console.error('[AINavigationManager] Error normalizing HTML:', e);
      return html;
    }
  }
  
  getTotalBlockCount(codeChunks, currentStreamChunk) {
    const count = codeChunks.length + (currentStreamChunk ? 1 : 0);
    //console.log('[AINavigationManager] Total block count:', count, 'chunks:', codeChunks.length, 'streaming:', !!currentStreamChunk);
    return count;
  }
  
    
  
  finalizeCurrentStreamChunk(instance) {
    if (instance.currentStreamChunk) {
      const messageHash = this.hashString(instance.currentStreamChunk.message);
      if (!instance.chunkIds.has(messageHash)) {
        instance.chunkIds.add(messageHash);
        instance.currentStreamChunk.id = messageHash;
        if (!instance.isStreaming) {
          instance.codeChunks.push({ ...instance.currentStreamChunk });
          //console.log(`[AINavigationManager] Finalized chunk for ${instance.constructor.name}, total: ${instance.codeChunks.length}`);
        } else {
          //console.log(`[AINavigationManager] Intermediate streaming chunk for ${instance.constructor.name}, not stored`);
        }
      }
      instance.currentStreamChunk = null;
      instance.currentBlockId = null;
      //console.log(`[AINavigationManager] Cleared currentStreamChunk for ${instance.constructor.name}`);
      if (this.getJumpToLatestEnabled()) {
        instance.goToLatestBlock();
      } else {
        this.updateNavigationState(instance);
      }
    }
  }
  
  displayStreamContent(message, blockId, instance) {
    //console.log(`[AINavigationManager] Displaying stream content for ${instance.constructor.name}, blockId:`, blockId);
    let wrapper = instance.messageDisplay.querySelector(`.code-block-wrapper[data-block-id="${blockId}"]`);
    let codeContainer;

    if (!wrapper) {
      instance.messageDisplay.innerHTML = '';
      wrapper = document.createElement('div');
      wrapper.className = 'code-block-wrapper';
      wrapper.dataset.blockId = blockId;

      if (instance.currentStreamChunk && instance.currentStreamChunk.prompt) {
        const promptContainer = document.createElement('div');
        promptContainer.className = 'prompt-container';
        promptContainer.textContent = instance.currentStreamChunk.prompt;
        wrapper.appendChild(promptContainer);
      }

      codeContainer = document.createElement('div');
      codeContainer.className = 'code-block-container';
      codeContainer.dataset.blockId = blockId;
      wrapper.appendChild(codeContainer);
      instance.messageDisplay.appendChild(wrapper);
      instance.codeViewer.createCodeBlock(codeContainer, blockId, message);
    } else {
      codeContainer = wrapper.querySelector(`.code-block-container[data-block-id="${blockId}"]`);
      instance.codeViewer.updateContent(blockId, message);
    }

    wrapper.classList.add('streaming-content');
  }
  
  displayCurrentChunk(instance) {
    if (!instance.messageDisplay) {
      console.error(`[AINavigationManager] messageDisplay is undefined for ${instance.constructor.name}`);
      return;
    }

    const totalCount = this.getTotalBlockCount(instance.codeChunks, instance.currentStreamChunk);
    if (totalCount === 0) {
      instance.messageDisplay.innerHTML = '<div><br>No code chunks available</div>';
      return;
    }

    instance.currentIndex = Math.max(0, Math.min(instance.currentIndex, totalCount - 1));
    instance.messageDisplay.innerHTML = '';

    const wrapper = document.createElement('div');
    wrapper.className = 'code-block-wrapper';

    let blockId, content, prompt;
    let chunk = null;

    if (instance.currentIndex < instance.codeChunks.length) {
      chunk = instance.codeChunks[instance.currentIndex];
      if (!chunk) {
        console.error(`[AINavigationManager] No chunk found at index for ${instance.constructor.name}:`, instance.currentIndex);
        return;
      }

      blockId = chunk.id || `block-${chunk.timestamp}`;
      content = chunk.message;
      prompt = chunk.prompt;
      wrapper.classList.add('complete');
      //console.log(`[AINavigationManager] Displaying stored chunk for ${instance.constructor.name} at index ${instance.currentIndex}:`, chunk.message.substring(0, 30) + '...');
    } else if (instance.currentStreamChunk) {
      blockId = instance.currentBlockId;
      content = instance.currentStreamChunk.message;
      prompt = instance.currentStreamChunk.prompt;
      wrapper.classList.add('streaming');
      //console.log(`[AINavigationManager] Displaying streaming chunk for ${instance.constructor.name}:`, instance.currentStreamChunk.message.substring(0, 30) + '...');
    } else {
      //console.error(`[AINavigationManager] Invalid state: No chunk to display for ${instance.constructor.name} at index`, instance.currentIndex);
      return;
    }

    wrapper.dataset.blockId = blockId;

    if (prompt) {
      const promptContainer = document.createElement('div');
      promptContainer.className = 'prompt-container';
      promptContainer.textContent = prompt;
      wrapper.appendChild(promptContainer);
    }

    const codeContainer = document.createElement('div');
    codeContainer.className = 'code-block-container';
    codeContainer.dataset.blockId = blockId;
    wrapper.appendChild(codeContainer);

    instance.messageDisplay.appendChild(wrapper);

    instance.codeViewer.createCodeBlock(codeContainer, blockId, content);

    // Always scroll to bottom when auto-scroll is enabled
    if (this.getAutoScrollEnabled()) {
      this.scrollToBottom(instance.messageDisplay, instance.codeViewer);
    }

    if (chunk) {
      this.setCurrentTimestamp(chunk.timestamp);
    } else if (instance.currentStreamChunk) {
      this.setCurrentTimestamp(instance.currentStreamChunk.timestamp);
    }

    //console.log(`[AINavigationManager] Displayed chunk for ${instance.constructor.name}, index:`, instance.currentIndex, 'total:', totalCount);
  }
  
  clearAll(instance) {
    instance.codeChunks = [];
    instance.chunkIds = instance.chunkIds || new Set();
    instance.chunkIds.clear();
    instance.currentStreamChunk = null;
    instance.currentBlockId = null;
    instance.currentIndex = -1;
    instance.isStreaming = false;

    if (instance.messageDisplay) {
      instance.messageDisplay.innerHTML = '<div><br>No code chunks available</div>';
    }

    this.updateNavigationState(instance);
    //console.log(`[AINavigationManager] All chunks cleared for ${instance.constructor.name}`);
  }
  
  deleteCurrentChunk(instance) {
    if (instance.currentIndex >= 0 && instance.currentIndex < instance.codeChunks.length) {
      const deletedChunk = instance.codeChunks.splice(instance.currentIndex, 1)[0];
      instance.chunkIds.delete(deletedChunk.id);
      if (instance.codeChunks.length === 0) {
        instance.currentIndex = -1;
      } else if (instance.currentIndex >= instance.codeChunks.length) {
        instance.currentIndex = instance.codeChunks.length - 1;
      }
      this.displayCurrentChunk(instance);
    } else if (instance.currentStreamChunk && instance.currentIndex === instance.codeChunks.length) {
      instance.currentStreamChunk = null;
      instance.currentBlockId = null;
      instance.currentIndex = instance.codeChunks.length - 1;
      this.displayCurrentChunk(instance);
    }
    
    this.updateNavigationState(instance);
  }
  
  updateNavigationState(instance) {
    const totalCount = this.getTotalBlockCount(instance.codeChunks, instance.currentStreamChunk);
    let timestamp = null;
    
    if (instance.currentIndex >= 0 && instance.currentIndex < instance.codeChunks.length) {
      const chunk = instance.codeChunks[instance.currentIndex];
      timestamp = chunk.timestamp;
    } else if (instance.currentStreamChunk) {
      timestamp = instance.currentStreamChunk.timestamp;
    }
    
    this.updateNavControls({
      currentIndex: instance.currentIndex,
      totalItems: totalCount,
      timestamp: timestamp
    });
  }
  
  refreshCodeBlocks(instance, activeTab) {
    //console.log(`[AINavigationManager] Refreshing code blocks for ${instance.constructor.name}...`);
    if (instance.currentStreamChunk) {
      this.finalizeCurrentStreamChunk(instance);
    }

    instance.codeChunks = [];
    instance.chunkIds = instance.chunkIds || new Set();
    instance.chunkIds.clear();
    instance.currentIndex = -1;

    window.postMessage({ type: 'refreshCodeBlocks', activeTab: activeTab }, '*');
    this.showStatusMessage('Refreshing code blocks...', 'refreshing');
  }
  
  getAutoScrollEnabled() {
    return this.autoScrollEnabled;
  }
  
  setAutoScrollEnabled(enabled) {
    this.autoScrollEnabled = enabled;
    this.updateScrollToggleButtonState();
  }
  
  getJumpToLatestEnabled() {
    return this.jumpToLatestEnabled;
  }
  
  setJumpToLatestEnabled(enabled) {
    this.jumpToLatestEnabled = enabled;
    this.updateJumpToggleButtonState();
  }
  
  getCurrentIndex() {
    return this.currentIndex;
  }
  
  setCurrentIndex(index) {
    this.currentIndex = index;
    this.updateNavControls();
  }
  
  getTotalItems() {
    return this.totalItems;
  }
  
  setTotalItems(count) {
    this.totalItems = count;
    this.updateNavControls();
  }
  
  destroy() {
    if (this.timeAgoUpdateInterval) {
      clearInterval(this.timeAgoUpdateInterval);
    }

    if (this.navContainer) {
      const buttons = this.navContainer.querySelectorAll('button');
      buttons.forEach(button => {
        button.replaceWith(button.cloneNode(true));
      });

      this.sliderElement.replaceWith(this.sliderElement.cloneNode(true));
    }

    if (this.topNavContainer) {
      const buttons = this.topNavContainer.querySelectorAll('button');
      buttons.forEach(button => {
        button.replaceWith(button.cloneNode(true));
      });

      this.topSliderElement.replaceWith(this.topSliderElement.cloneNode(true));
    }
  }

  createNavPanes() {
    this.navContainers = [];
    this.counterElements = [];
    this.timeAgoElements = [];
    this.sliderElements = [];

    this.panePositions.forEach((position, index) => {
      const paneId = `ai-nav-pane-${position}`;
      let navContainer = this.container.querySelector(`#${paneId}`);

      if (!navContainer) {
        navContainer = document.createElement('div');
        navContainer.id = paneId;
        navContainer.className = 'ai-nav-pane';
        navContainer.dataset.position = position;

        // Insert at appropriate position in container
        if (position === 'top') {
          this.container.insertBefore(navContainer, this.container.firstChild);
        } else {
          this.container.appendChild(navContainer);
        }
      }

      navContainer.innerHTML = `
        <button class="ai-nav-button ai-nav-left"><i class="fas fa-chevron-left"></i></button>
        <button class="ai-nav-button ai-nav-right"><i class="fas fa-chevron-right"></i></button>
        <span class="block-counter">0 / 0</span>
        <input type="range" class="ai-slider" min="0" max="0" value="0">
        <span class="time-ago">N/A</span>
        <button class="ai-nav-button ai-jump-toggle" title="Toggle Jump to Latest">→</button>
        <button class="ai-nav-button ai-scroll-toggle" title="Toggle Vertical Scroll">↓</button>
        <button class="ai-nav-button ai-refresh" title="Refresh Code Blocks"><i class="fas fa-sync-alt"></i></button>
        <button class="ai-nav-button ai-delete" title="Delete Current Chunk">X</button>
        <button class="ai-nav-button ai-clear-all" title="Clear All Chunks">Clear</button>
      `;

      // Store references to the elements of this pane
      this.navContainers.push(navContainer);
      this.counterElements.push(navContainer.querySelector('.block-counter'));
      this.timeAgoElements.push(navContainer.querySelector('.time-ago'));
      this.sliderElements.push(navContainer.querySelector('.ai-slider'));
    });

    this.updateScrollToggleButtonState();
    this.updateJumpToggleButtonState();
  }

  createTopNavPane() {
    this.topNavContainer = document.createElement('div');
    this.topNavContainer.className = 'ai-nav-pane ai-nav-pane-top';
    this.container.insertBefore(this.topNavContainer, this.container.firstChild);

    this.topNavContainer.innerHTML = `
      <button class="ai-nav-button ai-nav-left"><i class="fas fa-chevron-left"></i></button>
      <button class="ai-nav-button ai-nav-right"><i class="fas fa-chevron-right"></i></button>
      <span class="block-counter">0 / 0</span>
      <input type="range" class="ai-slider" min="0" max="0" value="0">
      <span class="time-ago">N/A</span>
      <button class="ai-nav-button ai-jump-toggle" title="Toggle Jump to Latest">→</button>
      <button class="ai-nav-button ai-scroll-toggle" title="Toggle Vertical Scroll">↓</button>
      <button class="ai-nav-button ai-refresh" title="Refresh Code Blocks"><i class="fas fa-sync-alt"></i></button>
      <button class="ai-nav-button ai-delete" title="Delete Current Chunk">X</button>
      <button class="ai-nav-button ai-clear-all" title="Clear All Chunks">Clear</button>
    `;

    this.topCounterElement = this.topNavContainer.querySelector('.block-counter');
    this.topTimeAgoElement = this.topNavContainer.querySelector('.time-ago');
    this.topSliderElement = this.topNavContainer.querySelector('.ai-slider');


  }
}



class Grok {
  constructor(container) {
    console.log('[Grok] Initializing Grok class...');
    this.container = container;
    this.contentContainer = container.querySelector('.ai-content');
    this.codeChunks = [];
    this.currentIndex = 0;
    this.codeComparer = new CodeComparer();
    this.codeViewer = new AICodeViewer(this.codeComparer);
    this.chunkIds = new Set();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
    
    this.navManager = new AINavigationManager(this.container, {
      autoScrollEnabled: true,
      jumpToLatestEnabled: true,
      onPrev: this.handlePrev.bind(this),
      onNext: this.handleNext.bind(this),
      onClear: () => this.navManager.clearAll(this),
      onDelete: () => this.navManager.deleteCurrentChunk(this),
      onRefresh: () => this.navManager.refreshCodeBlocks(this, 'grok'),
      onSliderChange: this.handleSliderChange.bind(this),
      onJumpToLatestToggle: this.handleJumpToLatestToggle.bind(this),
      onAutoScrollToggle: this.handleAutoScrollToggle.bind(this),
      onEditorCleanup: () => this.cleanupOldEditors() // Bind the new cleanup method
    });
    
    this.init();
    console.log('[Grok] Initialization complete');
  }
  
  init() {
    this.contentContainer.innerHTML = `<div id="messageDisplay"></div>`;
    this.messageDisplay = this.contentContainer.querySelector('#messageDisplay');
    
    this.goToLatestBlock();
    
    this.handleMessageBound = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessageBound);
    
    this.addBaseStyles();
  }
  
  addBaseStyles() {
    const style = document.createElement('style');
    style.textContent = `
      #messageDisplay {
        background-color: var(--bg-secondary);
        color: #e6e6e6;
        font-family: 'Arial', sans-serif;
        padding: 3px;
        height: 100%;
        box-sizing: border-box;
        overflow-y: auto;
        margin: 0;
      }

      .prompt-container {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        padding: 5px;
        margin-bottom: 5px;
        border-radius: 4px;
        font-family: 'Arial', sans-serif;
        border: 1px solid var(--border-color);
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .code-block-wrapper {
        margin-bottom: 5px;
        padding: 0;
      }

      .code-separator {
        height: 1px;
        background-color: #555;
        margin: 5px 0;
      }

      #messageDisplay {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
      }

      #messageDisplay::-webkit-scrollbar {
        width: 10px;
      }

      #messageDisplay::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      #messageDisplay::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 4px;
        border: 2px solid var(--bg-secondary);
        min-height: 30px;
      }
    `;
    document.head.appendChild(style);
  }
  
  handlePrev(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (this.isStreaming) {
      this.navManager.setJumpToLatestEnabled(false);
    }
  }
  
  handleNext(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (index === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleSliderChange(index) {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = Math.max(0, Math.min(index, totalCount - 1));
    this.navManager.displayCurrentChunk(this);
    
    if (this.isStreaming && this.currentIndex < totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(false);
    } else if (this.currentIndex === totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleJumpToLatestToggle(enabled) {
    if (enabled) {
      this.goToLatestBlock();
    }
  }
  
  handleAutoScrollToggle(enabled) {
    if (enabled) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
    handleMessage(event) {
    try {
      if (!event || !event.data || typeof event.data.type === 'undefined') {
        console.warn('[Grok] Received invalid event:', event);
        return;
      }

      if (event.data.type !== "grokMessage") return;

      const { message, language, prompt, name, isStreaming } = event.data;
      if (!message) return;

      //console.log('[Grok] Received message:', message.substring(0, 30) + '...', 'isStreaming:', isStreaming);

      this.isStreaming = isStreaming === true;
      const blockId = `block-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;

      // Check if this message is already the last finalized chunk
      const lastChunk = this.codeChunks.length ? this.codeChunks[this.codeChunks.length - 1] : null;
      if (lastChunk && lastChunk.message === message && !this.isStreaming) {
        //console.log('[Grok] Skipping duplicate finalized message:', message.substring(0, 30) + '...');
        return;
      }

      // Handle streaming continuation
      if (this.currentStreamChunk && this.currentBlockId) {
        if (this.navManager.isContinuation(this.currentStreamChunk.message, message)) {
          this.currentStreamChunk.message = message;
          if (this.currentIndex === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
            this.navManager.displayStreamContent(message, this.currentBlockId, this);
            if (this.navManager.getAutoScrollEnabled()) {
              this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
            }
          }
          this.navManager.updateNavigationState(this);
          return;
        } else if (!this.isStreaming) {
          // Finalize the current stream chunk if streaming has ended
          this.codeChunks.push({
            message: this.currentStreamChunk.message,
            language: this.currentStreamChunk.language || 'javascript',
            prompt: this.currentStreamChunk.prompt,
            name: this.currentStreamChunk.name,
            timestamp: this.currentStreamChunk.timestamp,
            id: this.currentBlockId
          });
          this.chunkIds.add(this.currentBlockId);
          this.currentStreamChunk = null;
          this.currentBlockId = null;
          this.navManager.updateNavigationState(this);
        }
      }

      // Start a new chunk if not a continuation and not a duplicate
      if (!this.currentStreamChunk) {
        this.currentBlockId = blockId;
        this.currentStreamChunk = {
          message,
          language: language || 'javascript',
          prompt,
          name,
          timestamp: Date.now()
        };

        const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
        if (this.navManager.getJumpToLatestEnabled()) {
          this.currentIndex = totalCount - 1;
          this.navManager.displayStreamContent(message, blockId, this);
          if (this.navManager.getAutoScrollEnabled()) {
            this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
          }
        }
        this.navManager.updateNavigationState(this);
      }

      // Auto-cleanup after stream ends
      if (!this.isStreaming && this.codeViewer.editors.size > 20) {
        this.cleanupOldEditors();
      }
    } catch (error) {
      console.error('[Grok] Error in handleMessage:', error);
    }
  }
  
  goToLatestBlock() {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = totalCount > 0 ? totalCount - 1 : 0;
    this.navManager.setJumpToLatestEnabled(true);
    this.navManager.displayCurrentChunk(this);
    this.navManager.updateNavigationState(this);
    if (this.navManager.getAutoScrollEnabled()) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  destroy() {
    this.codeViewer.destroyAll();
    window.removeEventListener("message", this.handleMessageBound);
    this.navManager.destroy();
    this.container.innerHTML = '';
    this.codeChunks = [];
    this.currentIndex = -1;
    this.chunkIds.clear();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
  }

  cleanupOldEditors() {
    const KEEP_CHUNKS = 10; // Keep editors for the last 10 chunks
    const recentChunkIds = this.codeChunks.slice(-KEEP_CHUNKS).map(chunk => chunk.id);
    const editorIds = Array.from(this.codeViewer.editors.keys());

    editorIds.forEach(blockId => {
      if (!recentChunkIds.includes(blockId) && blockId !== this.currentBlockId) {
        this.codeViewer.destroy(blockId);
      }
    });

    if (window.gc) window.gc(); // Hint garbage collection
    this.navManager.updateNavigationState(this);
    this.navManager.displayCurrentChunk(this); // Ensure current chunk is displayed
  }

  finalizeStreamChunk() {
    if (this.currentStreamChunk) {
      // Check if the chunk is already in codeChunks to avoid duplication
      const lastChunk = this.codeChunks[this.codeChunks.length - 1];
      if (!lastChunk || lastChunk.message !== this.currentStreamChunk.message) {
        this.codeChunks.push({ ...this.currentStreamChunk, id: this.currentBlockId });
        this.chunkIds.add(this.currentBlockId);
        //console.log('[Grok] Finalized chunk:', this.currentStreamChunk.message.substring(0, 30) + '...', 'Total chunks:', this.codeChunks.length);
      } else {
        //console.log('[Grok] Skipping duplicate chunk finalization:', this.currentStreamChunk.message.substring(0, 30) + '...');
      }
      this.navManager.finalizeCurrentStreamChunk(this); // Call navManager's finalize to update UI
      this.currentStreamChunk = null;
      this.currentBlockId = null;
    }
  }
}


class Claude {
  constructor(container) {
    console.log('[Claude] Initializing Claude class...');
    this.container = container;
    this.contentContainer = container.querySelector('.ai-content');
    this.codeChunks = [];
    this.currentIndex = 0;
    this.codeComparer = new CodeComparer();
    this.codeViewer = new AICodeViewer(this.codeComparer);
    this.chunkIds = new Set();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
    
    this.navManager = new AINavigationManager(this.container, {
      autoScrollEnabled: true,
      jumpToLatestEnabled: true,
      onPrev: this.handlePrev.bind(this),
      onNext: this.handleNext.bind(this),
      onClear: () => this.navManager.clearAll(this),
      onDelete: () => this.navManager.deleteCurrentChunk(this),
      onRefresh: () => this.navManager.refreshCodeBlocks(this, 'claude'),
      onSliderChange: this.handleSliderChange.bind(this),
      onJumpToLatestToggle: this.handleJumpToLatestToggle.bind(this),
      onAutoScrollToggle: this.handleAutoScrollToggle.bind(this),
      onEditorCleanup: () => this.cleanupOldEditors() // Added editor cleanup callback
    });
    
    this.init();
    console.log('[Claude] Initialization complete');
  }
  
  init() {
    this.contentContainer.innerHTML = `<div id="claudeMessageDisplay"></div>`;
    this.messageDisplay = this.contentContainer.querySelector('#claudeMessageDisplay');
    
    this.goToLatestBlock();
    
    this.handleMessageBound = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessageBound);
    
    this.addBaseStyles();
  }
  
  addBaseStyles() {
    const style = document.createElement('style');
    style.textContent = `
      #claudeMessageDisplay {
        background-color: var(--bg-secondary);
        color: #e6e6e6;
        font-family: 'Arial', sans-serif;
        padding: 3px;
        height: 100%;
        box-sizing: border-box;
        overflow-y: auto;
        margin: 0;
      }

      .prompt-container {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        padding: 5px;
        margin-bottom: 5px;
        border-radius: 4px;
        font-family: 'Arial', sans-serif;
        border: 1px solid var(--border-color);
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .code-block-wrapper {
        margin-bottom: 5px;
        padding: 0;
      }

      .code-separator {
        height: 1px;
        background-color: #555;
        margin: 5px 0;
      }

      #claudeMessageDisplay {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
      }

      #claudeMessageDisplay::-webkit-scrollbar {
        width: 10px;
      }

      #claudeMessageDisplay::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      #claudeMessageDisplay::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 4px;
        border: 2px solid var(--bg-secondary);
        min-height: 30px;
      }
    `;
    document.head.appendChild(style);
  }
  
  handlePrev(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (this.isStreaming) {
      this.navManager.setJumpToLatestEnabled(false);
    }
  }
  
  handleNext(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (index === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleSliderChange(index) {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = Math.max(0, Math.min(index, totalCount - 1));
    this.navManager.displayCurrentChunk(this);
    
    if (this.isStreaming && this.currentIndex < totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(false);
    } else if (this.currentIndex === totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleJumpToLatestToggle(enabled) {
    if (enabled) {
      this.goToLatestBlock();
    }
  }
  
  handleAutoScrollToggle(enabled) {
    if (enabled) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  handleMessage(event) {
    try {
      if (!event || !event.data || typeof event.data.type === 'undefined') {
        console.warn('[Claude] Received invalid event:', event);
        return;
      }

      if (event.data.type !== "claudeMessage") return;

      const { message, language, prompt, name, isStreaming } = event.data;
      if (!message) return;


      this.isStreaming = isStreaming === true;
      const blockId = this.currentBlockId || `block-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;

      if (this.currentStreamChunk) {
        if (this.navManager.isContinuation(this.currentStreamChunk.message, message)) {
          this.currentStreamChunk.message = message;
          if (this.currentIndex === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
            this.navManager.displayStreamContent(message, blockId, this);
            if (this.navManager.getAutoScrollEnabled()) {
              this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
            }
          }
          this.navManager.updateNavigationState(this);
          return;
        } else {
          this.navManager.finalizeCurrentStreamChunk(this);
        }
      }

      this.currentBlockId = blockId;
      this.currentStreamChunk = {
        message,
        language: language || 'javascript',
        prompt,
        name,
        timestamp: Date.now()
      };

      const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
      if (this.navManager.getJumpToLatestEnabled()) {
        this.currentIndex = totalCount - 1;
        this.navManager.displayStreamContent(message, blockId, this);
        if (this.navManager.getAutoScrollEnabled()) {
          this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
        }
      }
      this.navManager.updateNavigationState(this);

      // Auto-cleanup after stream ends
      if (!this.isStreaming && this.codeViewer.editors.size > 20) {
        this.cleanupOldEditors();
      }
    } catch (error) {
      console.error('[Claude] Error in handleMessage:', error);
    }
  }
  
  goToLatestBlock() {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = totalCount > 0 ? totalCount - 1 : 0;
    this.navManager.setJumpToLatestEnabled(true);
    this.navManager.displayCurrentChunk(this);
    this.navManager.updateNavigationState(this);
    if (this.navManager.getAutoScrollEnabled()) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  destroy() {
    this.codeViewer.destroyAll();
    window.removeEventListener("message", this.handleMessageBound);
    this.navManager.destroy();
    this.container.innerHTML = '';
    this.codeChunks = [];
    this.currentIndex = -1;
    this.chunkIds.clear();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
  }

  cleanupOldEditors() {
    const KEEP_CHUNKS = 10; // Keep editors for the last 10 chunks
    const recentChunkIds = this.codeChunks.slice(-KEEP_CHUNKS).map(chunk => chunk.id);
    const editorIds = Array.from(this.codeViewer.editors.keys());

    editorIds.forEach(blockId => {
      if (!recentChunkIds.includes(blockId) && blockId !== this.currentBlockId) {
        this.codeViewer.destroy(blockId);
      }
    });

    if (window.gc) window.gc(); // Hint garbage collection
    this.navManager.updateNavigationState(this);
    this.navManager.displayCurrentChunk(this); // Ensure current chunk is displayed
  }
}





class ChatGPT {
  constructor(container) {
    console.log('[ChatGPT] Initializing ChatGPT class...');
    this.container = container;
    this.contentContainer = container.querySelector('.ai-content');
    this.codeChunks = [];
    this.currentIndex = 0;
    this.codeComparer = new CodeComparer();
    this.codeViewer = new AICodeViewer(this.codeComparer);
    this.chunkIds = new Set();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
    
    this.navManager = new AINavigationManager(this.container, {
      autoScrollEnabled: true,
      jumpToLatestEnabled: true,
      onPrev: this.handlePrev.bind(this),
      onNext: this.handleNext.bind(this),
      onClear: () => this.navManager.clearAll(this),
      onDelete: () => this.navManager.deleteCurrentChunk(this),
      onRefresh: () => this.navManager.refreshCodeBlocks(this, 'chatgpt'),
      onSliderChange: this.handleSliderChange.bind(this),
      onJumpToLatestToggle: this.handleJumpToLatestToggle.bind(this),
      onAutoScrollToggle: this.handleAutoScrollToggle.bind(this),
      onEditorCleanup: () => this.cleanupOldEditors() // Added editor cleanup callback
    });
    
    this.init();
    console.log('[ChatGPT] Initialization complete');
  }
  
  init() {
    this.contentContainer.innerHTML = `<div id="chatgptMessageDisplay"></div>`;
    this.messageDisplay = this.contentContainer.querySelector('#chatgptMessageDisplay');
    
    this.goToLatestBlock();
    
    this.handleMessageBound = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessageBound);
    
    this.addBaseStyles();

    window.postMessage({ type: 'chatgptPing' }, '*');
  }
  
  addBaseStyles() {
    const style = document.createElement('style');
    style.textContent = `
      #chatgptMessageDisplay {
        background-color: var(--bg-secondary);
        color: #e6e6e6;
        font-family: 'Arial', sans-serif;
        padding: 3px;
        height: 100%;
        box-sizing: border-box;
        overflow-y: auto;
        margin: 0;
      }

      .prompt-container {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        padding: 5px;
        margin-bottom: 5px;
        border-radius: 4px;
        font-family: 'Arial', sans-serif;
        border: 1px solid var(--border-color);
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .code-block-wrapper {
        margin-bottom: 5px;
        padding: 0;
      }

      .code-separator {
        height: 1px;
        background-color: #555;
        margin: 5px 0;
      }

      #chatgptMessageDisplay {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
      }

      #chatgptMessageDisplay::-webkit-scrollbar {
        width: 10px;
      }

      #chatgptMessageDisplay::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      #chatgptMessageDisplay::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 4px;
        border: 2px solid var(--bg-secondary);
        min-height: 30px;
      }
    `;
    document.head.appendChild(style);
  }
  
  handlePrev(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (this.isStreaming) {
      this.navManager.setJumpToLatestEnabled(false);
    }
  }
  
  handleNext(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (index === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleSliderChange(index) {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = Math.max(0, Math.min(index, totalCount - 1));
    this.navManager.displayCurrentChunk(this);
    
    if (this.isStreaming && this.currentIndex < totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(false);
    } else if (this.currentIndex === totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleJumpToLatestToggle(enabled) {
    if (enabled) {
      this.goToLatestBlock();
    }
  }
  
  handleAutoScrollToggle(enabled) {
    if (enabled) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  handleMessage(event) {
    try {
      if (!event || !event.data || typeof event.data.type === 'undefined') {
        console.warn('[ChatGPT] Received invalid event:', event);
        return;
      }

      if (event.data.type === "chatgptExtensionReady") {
        console.log("[ChatGPT] Extension ready event received");
        return;
      }

      if (event.data.type !== "chatgptMessage") return;

      const { message, language, prompt, name, isStreaming } = event.data;
      if (!message) return;


      this.isStreaming = isStreaming === true;
      const blockId = this.currentBlockId || `block-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;

      if (this.currentStreamChunk) {
        if (this.navManager.isContinuation(this.currentStreamChunk.message, message)) {
          this.currentStreamChunk.message = message;
          if (this.currentIndex === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
            this.navManager.displayStreamContent(message, blockId, this);
            if (this.navManager.getAutoScrollEnabled()) {
              this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
            }
          }
          this.navManager.updateNavigationState(this);
          return;
        } else {
          this.navManager.finalizeCurrentStreamChunk(this);
        }
      }

      this.currentBlockId = blockId;
      this.currentStreamChunk = {
        message,
        language: language || 'javascript',
        prompt,
        name: name || 'ChatGPT',
        timestamp: Date.now()
      };

      const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
      if (this.navManager.getJumpToLatestEnabled()) {
        this.currentIndex = totalCount - 1;
        this.navManager.displayStreamContent(message, blockId, this);
        if (this.navManager.getAutoScrollEnabled()) {
          this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
        }
      }
      this.navManager.updateNavigationState(this);

      // Auto-cleanup after stream ends
      if (!this.isStreaming && this.codeViewer.editors.size > 20) {
        this.cleanupOldEditors();
      }
    } catch (error) {
      console.error('[ChatGPT] Error in handleMessage:', error);
    }
  }
  
  goToLatestBlock() {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = totalCount > 0 ? totalCount - 1 : 0;
    this.navManager.setJumpToLatestEnabled(true);
    this.navManager.displayCurrentChunk(this);
    this.navManager.updateNavigationState(this);
    if (this.navManager.getAutoScrollEnabled()) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  destroy() {
    this.codeViewer.destroyAll();
    window.removeEventListener("message", this.handleMessageBound);
    this.navManager.destroy();
    this.container.innerHTML = '';
    this.codeChunks = [];
    this.currentIndex = -1;
    this.chunkIds.clear();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
  }

  cleanupOldEditors() {
    const KEEP_CHUNKS = 10; // Keep editors for the last 10 chunks
    const recentChunkIds = this.codeChunks.slice(-KEEP_CHUNKS).map(chunk => chunk.id);
    const editorIds = Array.from(this.codeViewer.editors.keys());

    editorIds.forEach(blockId => {
      if (!recentChunkIds.includes(blockId) && blockId !== this.currentBlockId) {
        this.codeViewer.destroy(blockId);
      }
    });

    if (window.gc) window.gc(); // Hint garbage collection
    this.navManager.updateNavigationState(this);
    this.navManager.displayCurrentChunk(this); // Ensure current chunk is displayed
  }
}




class Gemini {
  constructor(container) {
    console.log('[Gemini] Initializing Gemini class...');
    this.container = container;
    this.contentContainer = container.querySelector('.ai-content');
    this.codeChunks = [];
    this.currentIndex = 0;
    this.codeComparer = new CodeComparer();
    this.codeViewer = new AICodeViewer(this.codeComparer);
    this.chunkIds = new Set();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
    
    this.navManager = new AINavigationManager(this.container, {
      autoScrollEnabled: true,
      jumpToLatestEnabled: true,
      onPrev: this.handlePrev.bind(this),
      onNext: this.handleNext.bind(this),
      onClear: () => this.navManager.clearAll(this),
      onDelete: () => this.navManager.deleteCurrentChunk(this),
      onRefresh: () => this.navManager.refreshCodeBlocks(this, 'gemini'),
      onSliderChange: this.handleSliderChange.bind(this),
      onJumpToLatestToggle: this.handleJumpToLatestToggle.bind(this),
      onAutoScrollToggle: this.handleAutoScrollToggle.bind(this),
      onEditorCleanup: () => this.cleanupOldEditors() // Added editor cleanup callback
    });
    
    this.init();
    console.log('[Gemini] Initialization complete');
  }
  
  init() {
    this.contentContainer.innerHTML = `<div id="geminiMessageDisplay"></div>`;
    this.messageDisplay = this.contentContainer.querySelector('#geminiMessageDisplay');
    
    this.goToLatestBlock();
    
    this.handleMessageBound = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessageBound);
    
    this.addBaseStyles();

    // Send a ping to check for connection
    window.postMessage({ type: 'geminiPing' }, '*');
  }
  
  addBaseStyles() {
    const style = document.createElement('style');
    style.textContent = `
      #geminiMessageDisplay {
        background-color: var(--bg-secondary);
        color: #e6e6e6;
        font-family: 'Arial', sans-serif;
        padding: 3px;
        height: 100%;
        box-sizing: border-box;
        overflow-y: auto;
        margin: 0;
      }

      .prompt-container {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        padding: 5px;
        margin-bottom: 5px;
        border-radius: 4px;
        font-family: 'Arial', sans-serif;
        border: 1px solid var(--border-color);
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .code-block-wrapper {
        margin-bottom: 5px;
        padding: 0;
      }

      .code-separator {
        height: 1px;
        background-color: #555;
        margin: 5px 0;
      }

      #geminiMessageDisplay {
        scrollbar-width: thin;
        scrollbar-color: var(--accent) var(--bg-secondary);
      }

      #geminiMessageDisplay::-webkit-scrollbar {
        width: 10px;
      }

      #geminiMessageDisplay::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      #geminiMessageDisplay::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 4px;
        border: 2px solid var(--bg-secondary);
        min-height: 30px;
      }
    `;
    document.head.appendChild(style);
  }
  
  handlePrev(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (this.isStreaming) {
      this.navManager.setJumpToLatestEnabled(false);
    }
  }
  
  handleNext(index) {
    this.currentIndex = index;
    this.navManager.displayCurrentChunk(this);
    if (index === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleSliderChange(index) {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = Math.max(0, Math.min(index, totalCount - 1));
    this.navManager.displayCurrentChunk(this);
    
    if (this.isStreaming && this.currentIndex < totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(false);
    } else if (this.currentIndex === totalCount - 1) {
      this.navManager.setJumpToLatestEnabled(true);
    }
  }
  
  handleJumpToLatestToggle(enabled) {
    if (enabled) {
      this.goToLatestBlock();
    }
  }
  
  handleAutoScrollToggle(enabled) {
    if (enabled) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  handleMessage(event) {
    try {
      if (!event || !event.data || typeof event.data.type === 'undefined') {
        console.warn('[Gemini] Received invalid event:', event);
        return;
      }

      if (event.data.type === "geminiExtensionReady") {
        console.log("[Gemini] Extension ready event received");
        return;
      }

      if (event.data.type !== "geminiMessage") return;

      const { message, language, prompt, name, isStreaming } = event.data;
      if (!message) return;

      console.log('[Gemini] Received message:', message.substring(0, 30) + '...', 'isStreaming:', isStreaming);

      this.isStreaming = isStreaming === true;
      const blockId = this.currentBlockId || `block-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;

      if (this.currentStreamChunk) {
        if (this.navManager.isContinuation(this.currentStreamChunk.message, message)) {
          this.currentStreamChunk.message = message;
          if (this.currentIndex === this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk) - 1) {
            this.navManager.displayStreamContent(message, blockId, this);
            if (this.navManager.getAutoScrollEnabled()) {
              this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
            }
          }
          this.navManager.updateNavigationState(this);
          return;
        } else {
          this.navManager.finalizeCurrentStreamChunk(this);
        }
      }

      this.currentBlockId = blockId;
      this.currentStreamChunk = {
        message,
        language: language || 'javascript',
        prompt,
        name: name || 'Gemini',
        timestamp: Date.now()
      };

      const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
      if (this.navManager.getJumpToLatestEnabled()) {
        this.currentIndex = totalCount - 1;
        this.navManager.displayStreamContent(message, blockId, this);
        if (this.navManager.getAutoScrollEnabled()) {
          this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
        }
      }
      this.navManager.updateNavigationState(this);

      // Auto-cleanup after stream ends
      if (!this.isStreaming && this.codeViewer.editors.size > 20) {
        this.cleanupOldEditors();
      }
    } catch (error) {
      console.error('[Gemini] Error in handleMessage:', error);
    }
  }
  
  goToLatestBlock() {
    const totalCount = this.navManager.getTotalBlockCount(this.codeChunks, this.currentStreamChunk);
    this.currentIndex = totalCount > 0 ? totalCount - 1 : 0;
    this.navManager.setJumpToLatestEnabled(true);
    this.navManager.displayCurrentChunk(this);
    this.navManager.updateNavigationState(this);
    if (this.navManager.getAutoScrollEnabled()) {
      this.navManager.scrollToBottom(this.messageDisplay, this.codeViewer);
    }
  }
  
  destroy() {
    this.codeViewer.destroyAll();
    window.removeEventListener("message", this.handleMessageBound);
    this.navManager.destroy();
    this.container.innerHTML = '';
    this.codeChunks = [];
    this.currentIndex = -1;
    this.chunkIds.clear();
    this.currentStreamChunk = null;
    this.currentBlockId = null;
    this.isStreaming = false;
  }

  cleanupOldEditors() {
    const KEEP_CHUNKS = 10; // Keep editors for the last 10 chunks
    const recentChunkIds = this.codeChunks.slice(-KEEP_CHUNKS).map(chunk => chunk.id);
    const editorIds = Array.from(this.codeViewer.editors.keys());

    editorIds.forEach(blockId => {
      if (!recentChunkIds.includes(blockId) && blockId !== this.currentBlockId) {
        this.codeViewer.destroy(blockId);
      }
    });

    if (window.gc) window.gc(); // Hint garbage collection
    this.navManager.updateNavigationState(this);
    this.navManager.displayCurrentChunk(this); // Ensure current chunk is displayed
  }
}




class Prompt {
    constructor() {
    this.extensionReady = false;
    this.promptButton = null;
    this.promptWindow = null;
    this.promptSelections = null;

    this.initializePrompt();

    window.addEventListener('grokExtensionReady', () => {
      console.log('Grok extension ready event received!');
      this.extensionReady = true;
    });

    window.addEventListener('message', (event) => {
      if (event.data.type === 'grokExtensionReady' || event.data.type === 'claudeExtensionReady') {
        console.log(`${event.data.type} message received!`);
        this.extensionReady = true;
      }
    });
  }

    initializePrompt() {
    this.addPromptStyles();
    this.createPromptButton();
    this.createPromptWindow();
    this.initializeDragging();
    this.setupEventListeners();
  }

    addPromptStyles() {
      const style = document.createElement('style');
      style.textContent = `
          .prompt-button {
              background-color: transparent;
              color: var(--text-primary);
              border: none;
              width: 32px;
              height: 32px;
              border-radius: 4px;
              cursor: pointer;
              transition: background-color 0.2s;
              display: flex;
              align-items: center;
              justify-content: center;
          }
    
          .prompt-button:hover {
              background-color: var(--accent);
          }
    
          .prompt-button i.fa-greater-than {
              font-size: 10px;
              margin-right: -3px;
              transform: translateY(-2px);
          }
    
          .prompt-button i.fa-underscore {
              font-size: 10px;
              transform: translateY(2px);
          }
    
          .prompt-window {
              display: none;
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background-color: var(--bg-secondary);
              border: 1px solid var(--border);
              border-radius: 8px;
              min-width: 600px;
              min-height: 300px;
              max-height: 90vh;
              z-index: 1000;
              resize: both;
              overflow: hidden;
              display: flex;
              flex-direction: column;
          }
    
          .prompt-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              padding: 10px;
              background-color: var(--bg-primary);
              border-bottom: 1px solid var(--border);
              cursor: move;
              border-radius: 8px 8px 0 0;
              flex-shrink: 0;
          }
    
          .prompt-title {
              color: var(--text-primary);
              font-size: 14px;
              font-weight: bold;
          }
    
          .prompt-close {
              background: none;
              border: none;
              color: var(--text-secondary);
              cursor: pointer;
              padding: 5px;
              font-size: 16px;
          }
    
          .prompt-close:hover {
              color: var(--text-primary);
          }
    
          .prompt-content {
              padding: 15px;
              display: flex;
              flex-direction: column;
              gap: 15px;
              flex: 1 1 auto;
              overflow-y: auto;
              min-height: 0;
              box-sizing: border-box;
          }
    
          .prompt-section {
              display: flex;
              flex-direction: column;
              gap: 8px;
          }
          
          .section-divider {
              height: 1px;
              background-color: var(--border);
              margin: 5px 0;
          }
    
          .section-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 4px;
          }
    
          .section-title {
              display: flex;
              align-items: center;
              gap: 8px;
          }
    
          .prompt-label {
              color: var(--text-primary);
              font-size: 12px;
              font-weight: bold;
          }
    
          .copy-icon-button {
              background: none;
              border: none;
              color: var(--text-secondary);
              cursor: pointer;
              font-size: 12px;
              padding: 2px;
              display: flex;
              align-items: center;
              justify-content: center;
          }
    
          .copy-icon-button:hover {
              color: var(--text-primary);
          }
    
          .prompt-textarea {
              background-color: var(--bg-primary);
              border: 1px solid var(--border);
              border-radius: 4px;
              color: var(--text-primary);
              padding: 8px;
              font-family: monospace;
              resize: vertical;
              min-height: 100px;
              width: 100%;
              box-sizing: border-box;
          }
    
          .prompt-selections {
              background-color: var(--bg-primary);
              border: 1px solid var(--border);
              border-radius: 4px;
              padding: 8px;
              min-height: 100px;
              position: relative;
          }
    
          .include-code {
              display: flex;
              align-items: center;
              gap: 8px;
              font-size: 12px;
              color: var(--text-primary);
          }
    
          .include-code input[type="checkbox"] {
              width: 14px;
              height: 14px;
              margin: 0;
          }
    
          .selections-header-buttons {
              display: flex;
              gap: 8px;
              align-items: center;
          }
    
          .clear-selections {
              background: var(--accent);
              border: none;
              color: var(--text-primary);
              padding: 2px 6px;
              border-radius: 3px;
              cursor: pointer;
              font-size: 11px;
              display: flex;
              align-items: center;
              gap: 4px;
          }
    
          .clear-selections:hover {
              background: var(--accent-hover);
          }
    
          .prompt-buttons {
              display: flex;
              gap: 10px;
              justify-content: space-between;
              padding: 10px;
              border-top: 1px solid var(--border);
              background-color: var(--bg-secondary);
              flex: 0 0 auto;
              position: sticky;
              bottom: 0;
              z-index: 1;
              min-height: 60px;
              align-items: center;
              box-sizing: border-box;
          }
    
          .buttons-left {
              display: flex;
              flex-direction: column;
              align-items: flex-start;
              gap: 5px;
          }
    
          .buttons-label {
              font-size: 11px;
              color: var(--text-secondary);
              margin-bottom: -2px;
          }
    
          .buttons-row {
              display: flex;
              gap: 10px;
          }
    
          .buttons-spacer {
              flex: 1;
          }
    
          .prompt-action-button {
              background-color: var(--accent);
              color: var(--text-primary);
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              transition: background-color 0.2s;
              font-size: 12px;
              display: flex;
              align-items: center;
              gap: 6px;
              white-space: nowrap;
          }
    
          .prompt-action-button i {
              font-size: 11px;
          }
    
          .prompt-action-button:hover {
              background-color: var(--accent-hover);
          }
    
          .prompt-action-button.grok {
              background-color: var(--success);
          }
    
          .prompt-action-button.grok:hover {
              background-color: var(--success-dark);
          }
    
          .prompt-action-button.claude {
              background-color: #e67e22;
          }
    
          .prompt-action-button.claude:hover {
              background-color: #d35400;
          }
    
          .post-prompt-tabs {
              display: flex;
              align-items: center;
              gap: 4px;
              margin-bottom: 8px;
              overflow-x: auto;
              padding-bottom: 2px;
          }
    
          .post-prompt-tab {
              display: flex;
              align-items: center;
              background-color: var(--accent);
              color: var(--text-primary);
              padding: 4px 8px;
              border-radius: 4px 4px 0 0;
              cursor: pointer;
              font-size: 12px;
              max-width: 250px;
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
          }
    
          .post-prompt-tab.active {
              background-color: var(--bg-primary);
              font-weight: bold;
          }
    
          .post-prompt-tab:hover:not(.active) {
              background-color: var(--accent-hover);
          }
    
          .tab-close {
              margin-left: 6px;
              font-size: 10px;
              opacity: 1;
              cursor: pointer;
              padding: 2px;
              min-width: 12px;
              min-height: 12px;
              display: flex;
              align-items: center;
              justify-content: center;
              position: relative;
              z-index: 2;
          }
    
          .tab-close:hover {
              background-color: rgba(255, 255, 255, 0.1);
              border-radius: 50%;
          }
    
          .add-tab-button {
              background-color: var(--accent);
              border: none;
              color: var(--text-primary);
              padding: 4px 8px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background-color 0.2s;
          }
    
          .add-tab-button:hover {
              background-color: var(--accent-hover);
          }
      `;
      document.head.appendChild(style);
    }

    createPromptButton() {
        const toolbarButtons = document.querySelector('.toolbar-buttons');
        this.promptButton = document.createElement('button');
        this.promptButton.className = 'toolbar-button prompt-button tooltip';
        this.promptButton.setAttribute('data-tooltip', 'Prompt Builder');
        this.promptButton.innerHTML = `<i class="fas fa-greater-than"></i><i class="fas fa-underscore"></i>`;
        const tabDivider = toolbarButtons.querySelector('.toolbar-divider');
        if (tabDivider) {
          toolbarButtons.insertBefore(this.promptButton, tabDivider);
        } else {
          toolbarButtons.appendChild(this.promptButton);
        }
    }

    createPromptWindow() {
      this.promptWindow = document.createElement('div');
      this.promptWindow.className = 'prompt-window';
      this.promptWindow.style.display = 'none';
      this.promptWindow.style.transform = 'translate(-50%, -50%)';
      this.promptWindow.innerHTML = `
          <div class="prompt-header">
              <div class="prompt-title">Prompt Builder</div>
              <button class="prompt-close">×</button>
          </div>
          <div class="prompt-content">
              <div class="prompt-section">
                  <div class="section-header">
                      <div class="section-title">
                          <label class="prompt-label">Prompt</label>
                          <button class="copy-icon-button" data-section="prompt">
                              <i class="fas fa-copy"></i>
                          </button>
                      </div>
                  </div>
                  <textarea class="prompt-textarea" id="promptInput"></textarea>
              </div>
              
              <div class="section-divider"></div>
              
              <div class="prompt-section">
                  <div class="section-header">
                      <div class="section-title">
                          <label class="prompt-label">Post Prompt</label>
                          <button class="copy-icon-button" data-section="postPrompt">
                              <i class="fas fa-copy"></i>
                          </button>
                      </div>
                  </div>
                  <div class="post-prompt-tabs" id="postPromptTabs"></div>
                  <textarea class="prompt-textarea" id="postPromptInput"></textarea>
              </div>
              
              <div class="section-divider"></div>
              
              <div class="prompt-section">
                  <div class="section-header">
                      <div class="section-title">
                          <label class="prompt-label">Code Selections</label>
                          <button class="copy-icon-button" data-section="selections">
                              <i class="fas fa-copy"></i>
                          </button>
                      </div>
                      <div class="selections-header-buttons">
                          <label class="include-code">
                              <input type="checkbox" id="includeFullCode"> Include full code
                          </label>
                          <button class="clear-selections">
                              <i class="fas fa-trash"></i> Clear
                          </button>
                      </div>
                  </div>
                  <div class="prompt-selections" id="promptSelections"></div>
              </div>
          </div>
          <div class="prompt-buttons">
              <div class="buttons-left">
                  <div class="buttons-label">Open new chat window with prompts:</div>
                  <div class="buttons-row">
                      <button class="prompt-action-button grok" id="grokPrompt">
                          <i class="fas fa-terminal"></i> Grok
                      </button>
                      <button class="prompt-action-button claude" id="claudePrompt">
                          <i class="fas fa-robot"></i> Claude
                      </button>
                  </div>
              </div>
              <div class="buttons-spacer"></div>
              <button class="prompt-action-button" id="addSelection">
                  <i class="fas fa-plus"></i> Add Selection
              </button>
              <button class="prompt-action-button" id="copyPrompts">
                  <i class="fas fa-copy"></i> Copy All
              </button>
          </div>
      `;
      document.body.appendChild(this.promptWindow);
    
      // Initialize PromptSelections
      const selectionsContainer = this.promptWindow.querySelector('#promptSelections');
      this.promptSelections = new PromptSelections(selectionsContainer);
    
      // Initialize post prompt tabs
      this.postPromptTabsContainer = this.promptWindow.querySelector('#postPromptTabs');
      this.postPromptTextarea = this.promptWindow.querySelector('#postPromptInput');
      this.tabs = [];
      this.activeTabId = null;
      this.createAddTabButton();
      this.loadTabsFromStorage();
    
      // Add click handler for the Add Selection button
      const addSelectionButton = document.getElementById('addSelection');
      addSelectionButton.addEventListener('click', () => {
        this.promptSelections.addCurrentSelection();
      });
    
      // Add click handler for clear selections button
      const clearSelectionsButton = this.promptWindow.querySelector('.clear-selections');
      clearSelectionsButton.addEventListener('click', () => {
        this.promptSelections.clear();
      });
    
      // Add click handlers for copy icon buttons
      this.promptWindow.querySelectorAll('.copy-icon-button').forEach(button => {
        button.addEventListener('click', () => {
          const section = button.dataset.section;
          this.copySectionContent(section);
        });
      });
    
      // Add change listener to update tab name and save content
      this.postPromptTextarea.addEventListener('input', () => {
        this.updateActiveTabName();
        this.saveTabsToStorage();
      });
      
      // Make sure content area grows with textarea expansion
      const textareas = this.promptWindow.querySelectorAll('.prompt-textarea');
      textareas.forEach(textarea => {
        textarea.addEventListener('input', () => {
          // Ensure content area scrolls properly
          this.promptWindow.querySelector('.prompt-content').style.minHeight = 'auto';
        });
      });
    }

    createAddTabButton() {
        this.addTabButton = document.createElement('button');
        this.addTabButton.className = 'add-tab-button';
        this.addTabButton.textContent = '+';
        this.addTabButton.addEventListener('click', () => this.addTab());
        this.postPromptTabsContainer.appendChild(this.addTabButton);
    }

    addTab(content = '') {
        const tabId = `post-prompt-tab-${Date.now()}`;
        const words = content.trim() ? content.trim().split(/\s+/) : ['New', 'Tab'];
        const tabName = words.slice(0, 3).join(' '); // Use up to 3 words
        
        const tab = {
          id: tabId,
          name: tabName,
          content: content
    };
    
        this.tabs.push(tab);
        this.renderTabs();
        this.switchTab(tabId);
        this.saveTabsToStorage();
    }

    removeTab(tabId) {
        const tabIndex = this.tabs.findIndex(tab => tab.id === tabId);
        if (tabIndex === -1) return;
    
        this.tabs.splice(tabIndex, 1);
    
        if (this.activeTabId === tabId) {
          const newActiveIndex = tabIndex > 0 ? tabIndex - 1 : 0;
          this.activeTabId = this.tabs.length > 0 ? this.tabs[newActiveIndex].id : null;
        }
    
        this.renderTabs();
        if (this.activeTabId) {
          this.switchTab(this.activeTabId);
        } else {
          this.postPromptTextarea.value = '';
        }
        this.saveTabsToStorage();
    }
    
    switchTab(tabId) {
        this.activeTabId = tabId;
        const activeTab = this.tabs.find(tab => tab.id === tabId);
        this.postPromptTextarea.value = activeTab ? activeTab.content : '';
        this.renderTabs();
    }

    renderTabs() {
      while (this.postPromptTabsContainer.firstChild && this.postPromptTabsContainer.firstChild !== this.addTabButton) {
        this.postPromptTabsContainer.removeChild(this.postPromptTabsContainer.firstChild);
      }

      this.tabs.forEach((tab, index) => {
        const tabElement = document.createElement('div');
        tabElement.className = `post-prompt-tab ${this.activeTabId === tab.id ? 'active' : ''}`;
        tabElement.dataset.tabId = tab.id;

        const nameSpan = document.createElement('span');
        nameSpan.textContent = `(${index + 1}) ${tab.name}`; 
        nameSpan.style.overflow = 'hidden';
        nameSpan.style.textOverflow = 'ellipsis';
        nameSpan.style.maxWidth = '220px';
        tabElement.appendChild(nameSpan);

        const closeButton = document.createElement('span');
        closeButton.className = 'tab-close';
        closeButton.textContent = '×';
        closeButton.style.flexShrink = '0';
        closeButton.addEventListener('click', (e) => {
          e.stopPropagation();
          this.removeTab(tab.id);
        });
        tabElement.appendChild(closeButton);

        tabElement.addEventListener('click', () => this.switchTab(tab.id));
        this.postPromptTabsContainer.insertBefore(tabElement, this.addTabButton);
      });

      if (!this.postPromptTabsContainer.contains(this.addTabButton)) {
        this.postPromptTabsContainer.appendChild(this.addTabButton);
      }
    }

    updateActiveTabName() {
        if (!this.activeTabId) return;
    
        const activeTab = this.tabs.find(tab => tab.id === this.activeTabId);
        if (activeTab) {
          const content = this.postPromptTextarea.value.trim();
          activeTab.content = content;
          const words = content ? content.split(/\s+/) : ['Empty'];
          activeTab.name = words.slice(0, 3).join(' '); // Use up to 3 words
          this.renderTabs();
        }
    }

    saveTabsToStorage() {
        localStorage.setItem('postPromptTabs', JSON.stringify(this.tabs));
        localStorage.setItem('activePostPromptTab', this.activeTabId);
    }

    loadTabsFromStorage() {
    const savedTabs = localStorage.getItem('postPromptTabs');
    const savedActiveTab = localStorage.getItem('activePostPromptTab');

    if (savedTabs) {
      this.tabs = JSON.parse(savedTabs);
      this.activeTabId = savedActiveTab;

      if (this.tabs.length === 0) {
        this.addTab(); // Create default tab if none exist
      } else {
        this.renderTabs();
        if (this.activeTabId) {
          this.switchTab(this.activeTabId);
        } else {
          this.switchTab(this.tabs[0].id);
        }
      }
    } else {
      this.addTab(); // Create default tab if no storage exists
    }
  }
  
    copySectionContent(section) {
        let content = '';
        const includeFullCode = document.getElementById('includeFullCode').checked;
    
        switch(section) {
            case 'prompt':
                content = document.getElementById('promptInput').value;
                break;
            case 'selections':
                content = this.promptSelections.getSelectionsText(includeFullCode);
                break;
            case 'postPrompt':
                content = this.postPromptTextarea.value;
                break;
        }
    
        if (content.trim()) {
            navigator.clipboard.writeText(content).then(() => {
                TextEditor.showStatusMessage(`${section} copied to clipboard`, true);
            });
        }
    }

    initializeDragging() {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
    
        const promptHeader = this.promptWindow.querySelector('.prompt-header');
    
        promptHeader.addEventListener('mousedown', (e) => {
          if (!e.target.classList.contains('prompt-close')) {
            const rect = this.promptWindow.getBoundingClientRect();
            isDragging = true;
            initialX = e.clientX - rect.left;
            initialY = e.clientY - rect.top;
            promptHeader.style.cursor = 'grabbing';
          }
        });
    
        document.addEventListener('mousemove', (e) => {
          if (isDragging) {
            e.preventDefault();
            const newX = e.clientX - initialX;
            const newY = e.clientY - initialY;
            this.promptWindow.style.left = `${newX}px`;
            this.promptWindow.style.top = `${newY}px`;
            this.promptWindow.style.transform = 'none';
          }
        });
    
        document.addEventListener('mouseup', () => {
          isDragging = false;
          promptHeader.style.cursor = 'move';
        });
    }

    setupEventListeners() {
        const closeButton = this.promptWindow.querySelector('.prompt-close');
        const copyButton = document.getElementById('copyPrompts');
        const grokButton = document.getElementById('grokPrompt');
        const claudeButton = document.getElementById('claudePrompt');
    
        // Toggle prompt window with button
        this.promptButton.addEventListener('click', () => {
          const isDisplayed = this.promptWindow.style.display === 'block';
          this.promptWindow.style.display = isDisplayed ? 'none' : 'block';
          this.promptButton.classList.toggle('active', !isDisplayed);
        });
    
        // Close only with X button
        closeButton.addEventListener('click', () => {
          this.promptWindow.style.display = 'none';
          this.promptButton.classList.remove('active');
        });
    
        // Action button listeners
        copyButton.addEventListener('click', () => this.copyPrompts());
        grokButton.addEventListener('click', () => this.grokPrompts());
        claudeButton.addEventListener('click', () => this.claudePrompts());
    }

    copyPrompts() {
        const promptText = document.getElementById('promptInput').value || '';
        const postPromptText = document.getElementById('postPromptInput').value || '';
        const includeFullCode = document.getElementById('includeFullCode').checked;
        const selectionsText = this.promptSelections.getSelectionsText(includeFullCode);
    
        let combinedText = [promptText, postPromptText, selectionsText]
          .filter(text => text.trim())
          .join('\n\n');
    
        if (includeFullCode) {
          let fullCode = '';
    
    
          try {
            // Attempt 1: Check for a TextEditor class
            if (typeof TextEditor !== 'undefined') {
              if (TextEditor.getActiveEditor) {
                const editor = TextEditor.getActiveEditor();
                fullCode = editor && editor.getText ? editor.getText() : '';
              }
            }
    
            // Attempt 2: Check common editor element selectors
            if (!fullCode) {
              const possibleEditors = [
                document.querySelector('.text-editor'),
                document.querySelector('.editor'),
                document.querySelector('[contenteditable="true"]'),
                document.querySelector('textarea:not(#promptInput):not(#postPromptInput)'),
                document.querySelector('.ace_editor textarea'),
                document.querySelector('.CodeMirror textarea')
              ];
    

              for (const editor of possibleEditors) {
                if (editor) {
                  fullCode = editor.textContent || editor.value || editor.innerText || '';
                  if (fullCode) {
                    break;
                  }
                }
              }
            }
    
            // Attempt 3: Check for window.editor or similar global
            if (!fullCode && window.editor && window.editor.getValue) {
              fullCode = window.editor.getValue();
            }
    
            // Log what we found and add with triple backticks
            if (fullCode.trim()) {
              console.log('Successfully got full code:', fullCode);
              combinedText += `\n\n\`\`\`\n${fullCode}\n\`\`\``;
            } else {
              console.log('No editor content found with any method');
            }
    
          } catch (error) {
            console.error('Error getting editor content:', error);
          }
        }
    
        if (combinedText.trim()) {
          navigator.clipboard.writeText(combinedText)
            .then(() => {
              TextEditor.showStatusMessage('All content copied to clipboard', true);
            })
            .catch(err => {
              console.error('Clipboard write failed:', err);
            });
        } else {
          console.log('Nothing to copy - combined text is empty');
        }
    }

    grokPrompts() {
        const promptText = document.getElementById('promptInput').value || '';
        const postPromptText = document.getElementById('postPromptInput').value || '';
        const includeFullCode = document.getElementById('includeFullCode').checked;
        const selectionsText = this.promptSelections.getSelectionsText(includeFullCode);

        const combinedText = [promptText, postPromptText, selectionsText]
            .filter(text => text.trim())
            .join('\n\n');

        if (!combinedText) {
            return;
        }

        const url = 'https://x.com/i/grok?text=' + encodeURIComponent(combinedText);

        if (this.extensionReady) {
            console.log('Grok extension is ready, sending message to open tab');
            window.postMessage({ type: 'openGrokTab', url: url }, '*');
        } else {
            console.log('Grok extension not ready, waiting...');
            setTimeout(() => this.grokPrompts(), 100);
        }
    }

    claudePrompts() {
        const promptText = document.getElementById('promptInput').value || '';
        const postPromptText = document.getElementById('postPromptInput').value || '';
        const includeFullCode = document.getElementById('includeFullCode').checked;
        const selectionsText = this.promptSelections.getSelectionsText(includeFullCode);

        const combinedText = [promptText, postPromptText, selectionsText]
            .filter(text => text.trim())
            .join('\n\n');

        if (!combinedText) {
            return;
        }

        const url = 'https://claude.ai/new?q=' + encodeURIComponent(combinedText);

        if (this.extensionReady) {
            console.log('Claude extension is ready, sending message to open tab');
            window.postMessage({ type: 'openClaudeTab', url: url }, '*');
        } else {
            console.log('Claude extension not ready, waiting...');
            setTimeout(() => this.claudePrompts(), 100);
        }
    }
}





class PromptSelections {
    constructor(container) {
        this.container = container;
        this.selections = [];
        this.setupStyles();
        this.render();
    }

    setupStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .selections-container {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: flex-start;
                min-height: 40px;
                padding: 8px;
            }

            .selection-bubble {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                background-color: var(--accent);
                border-radius: 16px;
                padding: 4px 12px;
                font-size: 12px;
                color: var(--text-primary);
                max-width: 200px;
                position: relative;
                transition: all 0.2s ease;
            }

            .selection-bubble:hover {
                background-color: var(--accent-hover);
                transform: translateX(2px);
            }

            .selection-text {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .selection-type {
                font-family: monospace;
                font-size: 11px;
                padding: 2px 4px;
                border-radius: 3px;
                font-weight: bold;
            }

            .selection-type.class {
                color: #ff9800;
                background-color: rgba(255, 152, 0, 0.1);
            }

            .selection-type.method {
                color: #2196f3;
                background-color: rgba(33, 150, 243, 0.1);
            }

            .selection-type.function {
                color: #4caf50;
                background-color: rgba(76, 175, 80, 0.1);
            }

            .selection-remove {
                cursor: pointer;
                opacity: 0.7;
                transition: opacity 0.2s;
                padding: 2px;
                font-size: 14px;
                margin-left: 4px;
            }

            .selection-remove:hover {
                opacity: 1;
            }

            .no-selections {
                color: var(--text-secondary);
                font-style: italic;
                font-size: 12px;
                padding: 8px;
            }
        `;
        document.head.appendChild(style);
    }

    render() {
        this.container.innerHTML = `<div class="selections-container"></div>`;
        this.selectionsContainer = this.container.querySelector('.selections-container');
        this.updateSelections();
    }

    getTypeIndicator(type) {
        switch (type.toLowerCase()) {
            case 'class':
            case 'classdeclaration':
                return {
                    text: 'C',
                    class: 'class'
                };
            case 'method':
            case 'methoddeclaration':
                return {
                    text: 'M',
                    class: 'method'
                };
            case 'function':
            case 'functiondeclaration':
            case 'arrowfunction':
                return {
                    text: 'F',
                    class: 'function'
                };
            default:
                return null;
        }
    }

    addSelection(selection) {
        this.selections.push(selection);
        this.updateSelections();
    }

    removeSelection(index) {
        this.selections.splice(index, 1);
        this.updateSelections();
    }

    updateSelections() {
        if (this.selections.length === 0) {
            this.selectionsContainer.innerHTML = `
                <div class="no-selections">No selections added yet</div>
            `;
            return;
        }

        this.selectionsContainer.innerHTML = this.selections.map((selection, index) => {
            const typeIndicator = this.getTypeIndicator(selection.type);
            const typeHtml = typeIndicator ? `
                <span class="selection-type ${typeIndicator.class}">${typeIndicator.text}</span>
            ` : '';

            // Escape HTML in the selection name to prevent rendering issues
            const escapedName = this.escapeHtml(selection.name || 'Selection');

            return `
                <div class="selection-bubble">
                    ${typeHtml}
                    <span class="selection-text">${escapedName}</span>
                    <span class="selection-remove" data-index="${index}">×</span>
                </div>
            `;
        }).join('');

        this.selectionsContainer.querySelectorAll('.selection-remove').forEach(button => {
            button.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.index);
                this.removeSelection(index);
            });
        });
    }

    addCurrentSelection() {
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;

        const selection = activeEditor.getSelectedText();
        if (!selection) return;

        const range = activeEditor.getSelectionRange();
        const startLine = range.start.row;
        const startCol = range.start.column;
        const endLine = range.end.row;
        const endCol = range.end.column;

        const parser = new CodeParser();
        const code = activeEditor.getValue();
        const ast = parser.parse(code);

        let foundNode = null;
        let foundType = '';

        // Helper function to get node at position
        const getNodeAtPosition = (node) => {
            if (node.start && node.end) {
                // Check if selection exactly matches node boundaries
                if (startLine === node.start.line &&
                    endLine === node.end.line &&
                    startCol === node.start.column &&
                    endCol === node.end.column) {

                    if (node.type === 'ClassDeclaration' ||
                        node.type === 'MethodDeclaration' ||
                        node.type === 'FunctionDeclaration' ||
                        node.type === 'ArrowFunction' ||
                        node.type === 'CSSRule') {
                        foundNode = node;
                        foundType = node.type;
                        return true;
                    }
                }
            }

            // If no exact match, check if selection is within a method
            if (node.methods) {
                for (const method of node.methods) {
                    if (startLine >= method.start.line &&
                        endLine <= method.end.line) {
                        foundNode = method;
                        foundType = 'MethodDeclaration';
                        return true;
                    }
                }
            }
            if (node.rules) {
                for (const rule of node.rules) {
                    if (startLine >= rule.start.line &&
                        endLine <= rule.end.line) {
                        foundNode = rule;
                        foundType = 'CSSRule';
                        return true;
                    }
                }
            }
            return false;
        };

        if (ast && ast.body) {
            ast.body.forEach(getNodeAtPosition);
        }

        let selectionName;
        if (foundNode) {
            if (foundNode.type === 'MethodDeclaration') {
                selectionName = foundNode.name;  // Just the method name
            } else if (foundNode.type === 'CSSRule') {
                selectionName = foundNode.name;
            } else {
                selectionName = foundNode.name;
                if (foundNode.parentClass && foundNode.type !== 'MethodDeclaration') {
                    selectionName = `${foundNode.parentClass}.${selectionName}`;
                }
            }
        } else {
            // If no specific node found, use the first few words of the selection
            // but make sure to handle HTML/CSS content safely
            selectionName = this.getSafeDisplayName(selection);
            foundType = 'text';
        }

        this.addSelection({
            name: selectionName,
            type: foundType,
            content: "```\n" + selection + "\n```",
            fullCode: code,
            node: foundNode
        });
    }


    getSelectionsText(includeFullCode = false) {
        if (this.selections.length === 0) return '';

        if (includeFullCode) {
            // Return both the selections and the full code when the checkbox is checked
            const selectionTexts = this.selections.map(selection => selection.content).join('\n\n');
            const fullCodes = this.selections
                .filter(sel => sel.fullCode)
                .map(sel => `Full code context:\n\`\`\`\n${sel.fullCode}\n\`\`\``)
                .join('\n\n');

            if (fullCodes) {
                return selectionTexts + '\n\n' + fullCodes;
            }
            return selectionTexts;
        } else {
            // Just return the selections without full code
            return this.selections.map(selection => selection.content).join('\n\n');
        }
    }

    clear() {
        this.selections = [];
        this.updateSelections();
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    getSafeDisplayName(content, defaultName = 'Selection') {
        if (!content) return defaultName;

        // Remove any HTML/XML tags for display
        let displayText = content.replace(/<[^>]*>/g, '');

        // Trim and get first few words
        displayText = displayText.trim();
        if (!displayText) return defaultName;

        const words = displayText.split(/\s+/).slice(0, 3);
        let name = words.join(' ');

        // Add ellipsis if truncated
        if (displayText.length > name.length) name += '...';

        return name || defaultName;
    }
}







class ASTViewer {
    constructor(container, editor) {
        this.container = container;
        this.editor = editor;
        this.ast = null;
        this.initialized = false;
        this.treeNodes = new Map();
        this.activeNode = null;
        this.currentHighlight = null;
        this.lastClickedNode = null;
        this.selectionAnchor = null;
        this.selectedNodes = new Set();
        this.hasFocus = false;
        this.expandedNodes = new Set();
        this.tempExpandedNodes = new Set();  // Add this line
        this.lastClickSource = null;         // Add this line
        this.parser = new CodeParser();

        this.container.innerHTML = '<div class="ast-loading">Initializing AST viewer...</div>';
        this.container.tabIndex = 0;
        this.preventEditorFocusSteal = false;

        // Add the highlight styles
        const astHighlightStyles = document.createElement('style');
        astHighlightStyles.textContent = `
            .ast-node.highlight {
                background-color: var(--accent);
                border-left: 3px solid #42a5f5;
                position: relative;
            }

            .ast-node.highlight::after {
                content: '';
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                width: 2px;
                background-color: #42a5f5;
            }
        `;
        document.head.appendChild(astHighlightStyles);

        setTimeout(() => {
            this.setupFocusManagement();
            this.initializeParser();
            this.setupClickToHighlight();
            const activeEditor = this.editor.getActiveEditor();
            if (activeEditor) {
                activeEditor.session.on('change', this.debounce(this.updateAST.bind(this), 500));
            }
            this.currentHighlight = { id: null, range: null };
        }, 100);
    }

        setupClickToHighlight() {
        const mainEditor = this.editor.getActiveEditor();
        if (!mainEditor) return;

        mainEditor.on('click', () => {
            if (!this.container.style.display || this.container.style.display !== 'none') {
                this.handleEditorClick();
            }
        });
    }

        handleEditorClick() {
        const mainEditor = this.editor.getActiveEditor();
        if (!mainEditor) return;

        const position = mainEditor.getCursorPosition();
        const code = mainEditor.getValue();
        const ast = this.parser.parse(code);

        // Clear any previous temporary expansions
        this.restorePreviousExpansions();

        // Clear any previous highlights from editor clicks
        if (this.lastClickSource === 'editor') {
            this.container.querySelectorAll('.ast-node').forEach(element => {
                element.classList.remove('highlight');
            });
        }

        const node = this.findNodeAtPosition(ast, position.row);
        if (node) {
            this.tempExpandedNodes = new Set(this.expandedNodes);
            this.expandToNode(node);
            this.highlightASTNode(node);
            this.lastClickSource = 'editor';
        }
    }

        findNodeAtPosition(ast, line) {
        let foundNode = null;

        const isLineInNode = (node) => {
            return node.start && node.end &&
                   line >= node.start.line &&
                   line <= node.end.line;
        };

        const traverse = (node) => {
            if (!node) return;

            if (isLineInNode(node)) {
                foundNode = node;

                if (node.type === 'ClassDeclaration' && node.methods) {
                    for (const method of node.methods) {
                        if (isLineInNode(method)) {
                            foundNode = method;
                            return;
                        }
                    }
                }

                if (node.type === 'StyleDeclaration' && node.rules) {
                    for (const rule of node.rules) {
                        if (isLineInNode(rule)) {
                            foundNode = rule;
                            return;
                        }
                    }
                }
            }
        };

        ast.body.forEach(traverse);
        return foundNode;
    }

        expandToNode(node) {
    const elements = Array.from(this.container.getElementsByClassName('ast-node'));
    const nodeElement = elements.find(element => {
      const nodeInfo = this.treeNodes.get(element);
      if (!nodeInfo) return false;

      if (node.type === 'MethodDeclaration') {
        return nodeInfo.node.fullName === node.fullName;
      } else if (node.type === 'CSSRule') {
        return nodeInfo.node.name === node.name;
      } else {
        return nodeInfo.node.name === node.name;
      }
    });

    if (nodeElement) {
      let parent = nodeElement.parentElement;
      while (parent) {
        const children = parent.querySelector('.ast-children');
        const toggle = parent.querySelector('.ast-toggle');
        if (children && toggle) {
          children.style.display = 'block';
          toggle.innerHTML = '▼';

          const parentNode = parent.querySelector('.ast-node');
          const nodeInfo = this.treeNodes.get(parentNode);
          if (nodeInfo && nodeInfo.node) {
            const nodeKey = `${nodeInfo.node.type}:${nodeInfo.node.name}`;
            this.expandedNodes.add(nodeKey);
          }
        }
        parent = parent.parentElement.closest('.ast-node-container');
      }

      // Calculate scroll position manually instead of using scrollIntoView
      const containerRect = this.container.getBoundingClientRect();
      const elementRect = nodeElement.getBoundingClientRect();
      const scrollTop = this.container.scrollTop;
      const relativeTop = elementRect.top - containerRect.top + scrollTop;
      const targetScroll = relativeTop - (containerRect.height / 2) + (elementRect.height / 2);

      // Smooth scroll with contained behavior
      this.container.scrollTo({
        top: targetScroll,
        behavior: 'smooth'
      });
    }
  }

    restorePreviousExpansions() {
        if (!this.tempExpandedNodes) return;

        const containers = this.container.querySelectorAll('.ast-node-container');
        containers.forEach(container => {
            const nodeElement = container.querySelector('.ast-node');
            const children = container.querySelector('.ast-children');
            const toggle = container.querySelector('.ast-toggle');

            if (children && toggle) {
                const nodeInfo = this.treeNodes.get(nodeElement);
                if (nodeInfo && nodeInfo.node) {
                    const nodeKey = `${nodeInfo.node.type}:${nodeInfo.node.name}`;

                    if (!this.tempExpandedNodes.has(nodeKey)) {
                        children.style.display = 'none';
                        toggle.innerHTML = '▶';
                    }
                }
            }
        });

        this.expandedNodes = new Set(this.tempExpandedNodes);
        this.tempExpandedNodes = null;
    }
    
    highlightASTNode(node) {
        this.container.querySelectorAll('.ast-node').forEach(element => {
          element.classList.remove('highlight');
        });
    
        const elements = Array.from(this.container.getElementsByClassName('ast-node'));
        const nodeElement = elements.find(element => {
          const nodeInfo = this.treeNodes.get(element);
          if (!nodeInfo) return false;
    
          if (node.type === 'MethodDeclaration') {
            return nodeInfo.node.fullName === node.fullName;
          } else if (node.type === 'CSSRule') {
            return nodeInfo.node.name === node.name;
          } else {
            return nodeInfo.node.name === node.name;
          }
        });
    
        if (nodeElement) {
          nodeElement.classList.add('highlight');
          // Use manual scroll calculation instead of scrollIntoView
          const containerRect = this.container.getBoundingClientRect();
          const elementRect = nodeElement.getBoundingClientRect();
          const scrollTop = this.container.scrollTop;
          const relativeTop = elementRect.top - containerRect.top + scrollTop;
          const targetScroll = relativeTop - (containerRect.height / 2) + (elementRect.height / 2);
    
          this.container.scrollTo({
            top: targetScroll,
            behavior: 'smooth'
          });
        }
    }
    
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    async initializeParser() {
        try {
            this.initialized = true;
            this.parser = new CodeParser(); // Make sure parser is instantiated
            this.handleCodeChange();
        } catch (error) {
            console.error('Failed to initialize parser:', error);
            this.container.innerHTML = '<div class="ast-error">Error initializing parser: ' + error.message + '</div>';
        }
    }

    handleCodeChange() {
        if (!this.initialized) {
            return;
        }

        const activeEditor = this.editor.getActiveEditor();
        if (!activeEditor) {
            this.container.innerHTML = '<div class="ast-empty">No editor available</div>';
            return;
        }

        const code = activeEditor.getValue().trim();
        if (!code) {
            this.container.innerHTML = '<div class="ast-empty">No code to parse</div>';
            return;
        }

        try {
            this.container.innerHTML = '<div class="ast-loading">Parsing code...</div>';
            const ast = this.parser.parse(code);
            this.ast = ast;
            this.renderAST(ast);
        } catch (error) {
            console.error('Error parsing code:', error);
            this.container.innerHTML = '<div class="ast-error">Error parsing code: ' + error.message + '</div>';
        }
    }

    updateAST() {
        if (!this.initialized) {
            this.initialized = true;
        }
        this.handleCodeChange();
    }

    parseAndRender(code) {
        const ast = this.parseCode(code);
        this.renderAST(ast);
    }

    calculateSizeInfo(node, parentSize = null) {
        const lines = node.end.line - node.start.line + 1;
        let percentage = 0;
        let color = '';
    
        if (!parentSize) {
            let maxLines = 0;
            const nodes = this.parser.findNodesByType('ClassDeclaration')
                .concat(this.parser.findNodesByType('FunctionDeclaration'))
                .concat(this.parser.findNodesByType('ArrowFunction'));
            
            nodes.forEach(node => {
                const nodeLines = node.end.line - node.start.line + 1;
                maxLines = Math.max(maxLines, nodeLines);
            });
            percentage = (lines / maxLines) * 100;
        } else {
            percentage = (lines / parentSize) * 100;
        }
    
        const hue = Math.max(0, 120 - (percentage * 1.2));
        color = `hsla(${hue}, 80%, 40%, 0.2)`;
    
        return { lines, percentage, color };
    }

    createNodeElement(node, depth = 0) {
        const container = document.createElement('div');
        container.className = 'ast-node-container';
        container.style.marginLeft = `${depth * 20}px`;

        const header = document.createElement('div');
        header.className = `ast-node ${node.type.toLowerCase()}-node`;

        let parentSize = null;
        if (node.type === 'MethodDeclaration' || node.type === 'CSSRule') {
            const parent = this.findParentNode(node);
            if (parent) {
                parentSize = parent.end.line - parent.start.line + 1;
            }
        }

        const { lines, percentage, color } = this.calculateSizeInfo(node, parentSize);

        const barContainer = document.createElement('div');
        barContainer.className = 'line-count-bar-container';

        const bar = document.createElement('div');
        bar.className = 'line-count-bar';
        bar.style.width = `${percentage}%`;
        bar.style.backgroundColor = color;

        barContainer.appendChild(bar);
        header.appendChild(barContainer);

        const toggle = document.createElement('span');
        toggle.className = 'ast-toggle';
        const hasChildren = node.methods?.length > 0 || (node.type === 'StyleDeclaration' && node.rules?.length > 0);
        const nodeKey = `${node.type}:${node.name}`;
        const isExpanded = this.expandedNodes.has(nodeKey);

        if (hasChildren) {
            toggle.innerHTML = isExpanded ? '▼' : '▶';
            toggle.style.cursor = 'pointer';
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleToggleClick(toggle, container, nodeKey);
            });
        } else {
            toggle.innerHTML = '  ';
            toggle.style.cursor = 'default';
        }
        header.appendChild(toggle);

        const content = document.createElement('span');
        content.className = 'ast-content';

        const lineCount = document.createElement('span');
        lineCount.className = 'line-count';
        if (parentSize) {
            lineCount.textContent = ` (${lines} - ${percentage.toFixed(1)}%)`;
        } else {
            lineCount.textContent = ` (${lines})`;
        }

        if (node.type === 'StyleDeclaration') {
            content.textContent = '<style>';
        } else if (node.type === 'CSSRule') {
            content.textContent = node.name;
        } else if (node.type === 'MethodDeclaration') {
            content.textContent = node.fullDeclaration || `${node.name}()`;
        } else if (node.type === 'FunctionDeclaration' || node.type === 'ArrowFunction') {
            content.textContent = node.fullDeclaration || `${node.name}()`;
        } else if (node.type === 'EventListener') {
            content.textContent = `🎯 ${node.name}`;
        } else {
            content.textContent = node.name;
        }

        content.appendChild(lineCount);
        header.appendChild(content);
        container.appendChild(header);

        this.treeNodes.set(header, {
            node,
            start: node.start,
            end: node.end,
            isClass: node.type === 'ClassDeclaration' || node.type === 'StyleDeclaration'
        });

        header.addEventListener('click', (e) => {
            this.handleNodeClick(header, container, e);
        });

        if (hasChildren) {
            const children = document.createElement('div');
            children.className = 'ast-children';
            children.style.display = isExpanded ? 'block' : 'none';
            const childNodes = node.type === 'StyleDeclaration' ? node.rules : node.methods;
            childNodes.forEach(child => {
                children.appendChild(this.createNodeElement(child, depth + 1));
            });
            container.appendChild(children);
        }

        return container;
    }

    findParentNode(node) {
        if (!node) return null;
    
        const allClasses = this.parser.findNodesByType('ClassDeclaration');
        for (const classNode of allClasses) {
            if (classNode.methods?.some(method => 
                method.start.line === node.start.line && 
                method.end.line === node.end.line &&
                method.start.column === node.start.column &&
                method.end.column === node.end.column)) {
                return classNode;
            }
        }
    
        const allStyles = this.parser.findNodesByType('StyleDeclaration');
        for (const styleNode of allStyles) {
            if (styleNode.rules?.some(rule => 
                rule.start.line === node.start.line && 
                rule.end.line === node.end.line &&
                rule.start.column === node.start.column &&
                rule.end.column === node.end.column)) {
                return styleNode;
            }
        }
        return null;
    }

    handleToggleClick(toggle, container, nodeKey) {
        const children = container.querySelector('.ast-children');
        if (children) {
            const isExpanded = children.style.display !== 'none';
            children.style.display = isExpanded ? 'none' : 'block';
            toggle.innerHTML = isExpanded ? '▶' : '▼';
            if (isExpanded) {
                this.expandedNodes.delete(nodeKey);
            } else {
                this.expandedNodes.add(nodeKey);
            }
            this.tempExpandedNodes = new Set(this.expandedNodes);
        }
    }

    renderAST(ast) {
        this.container.innerHTML = '';
        const treeContainer = document.createElement('div');
        treeContainer.className = 'ast-tree';

        ast.body.forEach(node => {
            treeContainer.appendChild(this.createNodeElement(node));
        });

        this.container.appendChild(treeContainer);
    }

    handleNodeClick(header, container, event) {
        event.stopPropagation();

        this.container.focus();
        this.lastClickSource = 'ast';

        // Clear any highlight that came from editor clicks
        if (this.lastClickSource === 'ast') {
            this.container.querySelectorAll('.ast-node').forEach(element => {
                element.classList.remove('highlight');
            });
        }

        const nodeInfo = this.treeNodes.get(header);
        if (!nodeInfo) return;

        if (event.shiftKey) {
            if (!this.selectionAnchor) {
                this.selectionAnchor = this.lastClickedNode || header;
            }
            this.lastClickedNode = header;
            this.handleShiftClick(header, nodeInfo);
        } else {
            this.clearSelection();
            if (nodeInfo.isClass) {
                this.selectClassNode(header, nodeInfo);
            } else {
                this.selectNode(header, nodeInfo);
            }
            this.lastClickedNode = header;
            this.selectionAnchor = header;
        }
    }


    setupFocusManagement() {
        this.container.tabIndex = 0;

        this.container.addEventListener('focus', () => {
            this.hasFocus = true;
            this.container.classList.add('has-focus');
            if (this.selectedNodes.size > 0) {
                const firstNode = this.selectedNodes.values().next().value;
                const nodeInfo = this.treeNodes.get(firstNode);
                if (nodeInfo) {
                    let minLine = nodeInfo.start.line;
                    let minColumn = nodeInfo.start.column;
                    let maxLine = nodeInfo.end.line;
                    let maxColumn = nodeInfo.end.column;

                    this.selectedNodes.forEach(node => {
                        const info = this.treeNodes.get(node);
                        if (info) {
                            if (info.start.line < minLine || (info.start.line === minLine && info.start.column < minColumn)) {
                                minLine = info.start.line;
                                minColumn = info.start.column;
                            }
                            if (info.end.line > maxLine || (info.end.line === maxLine && info.end.column > maxColumn)) {
                                maxLine = info.end.line;
                                maxColumn = info.end.column;
                            }
                        }
                    });

                    this.highlightCodeWithoutFocus({line: minLine, column: minColumn}, {line: maxLine, column: maxColumn});
                }
            }
        });

        this.container.addEventListener('blur', () => {
            this.hasFocus = false;
            this.container.classList.remove('has-focus');
            this.clearHighlight();
        });

        this.container.addEventListener('mousedown', () => {
            this.preventEditorFocusSteal = true;
            this.container.focus();
        });

        document.addEventListener('mousedown', (e) => {
            if (!this.container.contains(e.target)) {
                this.preventEditorFocusSteal = false;
            }
        });

        this.container.addEventListener('keydown', (e) => this.handleKeyDown(e));
    }


    handleKeyDown(event) {
        if (!this.hasFocus) return;

        const navigationKeys = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'];
        const isNavigationKey = navigationKeys.includes(event.key);

        // Handle Shift key by itself
        if (event.key === 'Shift') {
            event.preventDefault();
            event.stopPropagation();
            return;
        }

        // Handle navigation keys
        if (isNavigationKey) {
            event.preventDefault();
            event.stopPropagation();

            switch (event.key) {
                case 'ArrowDown':
                case 'ArrowUp':
                    const direction = event.key === 'ArrowDown' ? 1 : -1;
                    const visibleNodes = this.getVisibleNodes();
                    if (!visibleNodes.length) return;

                    let currentIndex = this.activeNode ? visibleNodes.indexOf(this.activeNode) : -1;
                    let nextIndex = currentIndex === -1 ? 0 : Math.max(0, Math.min(currentIndex + direction, visibleNodes.length - 1));

                    if (event.shiftKey) {
                        if (!this.selectionAnchor) {
                            this.selectionAnchor = currentIndex === -1 ? visibleNodes[0] : visibleNodes[currentIndex];
                        }

                        const anchorIndex = visibleNodes.indexOf(this.selectionAnchor);
                        const selectionStart = Math.min(anchorIndex, nextIndex);
                        const selectionEnd = Math.max(anchorIndex, nextIndex);

                        this.selectedNodes.forEach(node => {
                            node.classList.remove('active');
                        });
                        this.selectedNodes.clear();

                        let minLine = Infinity;
                        let minColumn = Infinity;
                        let maxLine = -Infinity;
                        let maxColumn = -Infinity;

                        for (let i = selectionStart; i <= selectionEnd; i++) {
                            const node = visibleNodes[i];
                            const nodeInfo = this.treeNodes.get(node);
                            if (nodeInfo) {
                                minLine = Math.min(minLine, nodeInfo.start.line);
                                minColumn = Math.min(minColumn, nodeInfo.start.column);
                                maxLine = Math.max(maxLine, nodeInfo.end.line);
                                maxColumn = Math.max(maxColumn, nodeInfo.end.column);
                                node.classList.add('active');
                                this.selectedNodes.add(node);
                            }
                        }

                        this.highlightCodeWithoutFocus(
                            {line: minLine, column: minColumn},
                            {line: maxLine, column: maxColumn}
                        );

                        this.activeNode = visibleNodes[nextIndex];
                    } else {
                        this.selectionAnchor = null;
                        this.clearSelection();
                        const nextNode = visibleNodes[nextIndex];
                        const nodeInfo = this.treeNodes.get(nextNode);

                        if (nodeInfo) {
                            this.selectNode(nextNode, nodeInfo, false);
                            this.activeNode = nextNode;
                            this.selectionAnchor = nextNode;
                        }
                    }

                    if (this.activeNode) {
                        this.scrollNodeIntoView(this.activeNode);
                    }
                    break;

                case 'ArrowRight':
                    this.expandCurrentNode();
                    break;

                case 'ArrowLeft':
                    this.collapseCurrentNode();
                    break;
            }
            return;
        }

        // For all other keys, focus the editor and let it handle the key
        const mainEditor = this.editor.getActiveEditor();
        if (mainEditor) {
            this.preventEditorFocusSteal = false;
            mainEditor.focus();

            // Forward the key event to the editor
            const syntheticEvent = new KeyboardEvent('keydown', {
                key: event.key,
                code: event.code,
                ctrlKey: event.ctrlKey,
                shiftKey: event.shiftKey,
                altKey: event.altKey,
                metaKey: event.metaKey,
                bubbles: true
            });
            mainEditor.textInput.getElement().dispatchEvent(syntheticEvent);
        }
    }

    expandCurrentNode() {
        if (!this.activeNode) return;
        
        const container = this.activeNode.closest('.ast-node-container');
        const toggle = this.activeNode.querySelector('.ast-toggle');
        const children = container.querySelector('.ast-children');
        const nodeInfo = this.treeNodes.get(this.activeNode);
        
        if (children && toggle) {
            const isExpandable = nodeInfo && (
                (nodeInfo.node.type === 'ClassDeclaration' && nodeInfo.node.methods?.length > 0) ||
                (nodeInfo.node.type === 'StyleDeclaration' && nodeInfo.node.rules?.length > 0)
            );
            
            if (isExpandable && children.style.display === 'none') {
                children.style.display = 'block';
                toggle.innerHTML = '▼';
                const nodeKey = `${nodeInfo.node.type}:${nodeInfo.node.name}`;
                this.expandedNodes.add(nodeKey);
                this.scrollNodeIntoView(this.activeNode);
            }
        }
    }

    collapseCurrentNode() {
        if (!this.activeNode) return;
        
        const container = this.activeNode.closest('.ast-node-container');
        const toggle = this.activeNode.querySelector('.ast-toggle');
        const children = container.querySelector('.ast-children');
        const nodeInfo = this.treeNodes.get(this.activeNode);
        
        if (children && toggle && children.style.display !== 'none') {
            children.style.display = 'none';
            toggle.innerHTML = '▶';
            if (nodeInfo) {
                const nodeKey = `${nodeInfo.node.type}:${nodeInfo.node.name}`;
                this.expandedNodes.delete(nodeKey);
                this.selectNode(this.activeNode, nodeInfo);
                this.scrollNodeIntoView(this.activeNode);
            }
        } else {
            const parentContainer = container.parentElement?.closest('.ast-node-container');
            if (parentContainer) {
                const parentNode = parentContainer.querySelector('.ast-node');
                const parentToggle = parentNode?.querySelector('.ast-toggle');
                const parentChildren = parentContainer.querySelector('.ast-children');
                const parentNodeInfo = this.treeNodes.get(parentNode);
                
                if (parentChildren && parentToggle && parentNodeInfo) {
                    parentChildren.style.display = 'none';
                    parentToggle.innerHTML = '▶';
                    const nodeKey = `${parentNodeInfo.node.type}:${parentNodeInfo.node.name}`;
                    this.expandedNodes.delete(nodeKey);
                    this.clearSelection();
                    this.selectNode(parentNode, parentNodeInfo);
                    this.scrollNodeIntoView(parentNode);
                }
            }
        }
    }


    getVisibleNodes() {
        const visibleNodes = [];
        const traverse = (element) => {
            if (element.classList.contains('ast-node')) {
                if (this.isNodeVisible(element)) {
                    visibleNodes.push(element);
                }
            }
            
            Array.from(element.children).forEach(child => {
                if (!child.classList.contains('ast-children') || 
                    child.style.display !== 'none') {
                    traverse(child);
                }
            });
        };
        
        traverse(this.container);
        return visibleNodes;
    }

    isNodeVisible(node) {
        let current = node;
        while (current && current !== this.container) {
            if (current.classList.contains('ast-children') && 
                current.style.display === 'none') {
                return false;
            }
            current = current.parentElement;
        }
        return true;
    }

    scrollNodeIntoView(node) {
        const containerRect = this.container.getBoundingClientRect();
        const nodeRect = node.getBoundingClientRect();
        
        const visibleTop = this.container.scrollTop;
        const visibleBottom = visibleTop + containerRect.height;
        const nodeTop = nodeRect.top - containerRect.top + this.container.scrollTop;
        const nodeBottom = nodeTop + nodeRect.height;
        
        const margin = 30;
        
        if (nodeTop < visibleTop + margin) {
            this.container.scrollTo({
                top: nodeTop - margin,
                behavior: 'smooth'
            });
        } else if (nodeBottom > visibleBottom - margin) {
            this.container.scrollTo({
                top: nodeBottom - containerRect.height + margin,
                behavior: 'smooth'
            });
        }
    }

    selectClassNode(header, nodeInfo) {
        header.classList.add('active');
        this.selectedNodes.add(header);
        this.activeNode = header;

        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            this.highlightCodeWithoutFocus(nodeInfo.start, nodeInfo.end);
            activeEditor.scrollToLine(nodeInfo.start.line, true, true);
        }
    }

    getAllNodes() {
        return Array.from(this.treeNodes.keys());
    }
    
    findNodesBetween(startNode, endNode) {
        const allNodes = this.getAllNodes();
        const startIndex = allNodes.indexOf(startNode);
        const endIndex = allNodes.indexOf(endNode);
        
        if (startIndex === -1 || endIndex === -1) return [];
        
        const start = Math.min(startIndex, endIndex);
        const end = Math.max(startIndex, endIndex);
        
        return allNodes.slice(start, end + 1);
    }
    
    selectNode(header, nodeInfo, focusEditor = false) {
        header.classList.add('active');
        this.selectedNodes.add(header);
        this.activeNode = header;

        const Range = ace.require('ace/range').Range;
        const range = new Range(
            nodeInfo.start.line,
            nodeInfo.start.column,
            nodeInfo.end.line,
            nodeInfo.end.column
        );

        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.selection.setRange(range, false);
            activeEditor.scrollToLine(nodeInfo.start.line, true, true);
            this.currentHighlight = { id: null, range: range };
            if (focusEditor) {
                activeEditor.focus();
            }
        } else {
            this.currentHighlight = { id: null, range: range };
        }
    }
    
    clearSelection() {
        this.selectedNodes.forEach(node => {
            node.classList.remove('active');
        });
        this.selectedNodes.clear();

        if (this.hasFocus) {
            const activeEditor = this.editor.getActiveEditor();
            if (activeEditor) {
                activeEditor.selection.clearSelection();
            }
        }
        this.currentHighlight = null;
    }
    
    highlightCodeWithoutFocus(start, end) {
        const Range = ace.require('ace/range').Range;
        const range = new Range(start.line, start.column, end.line, end.column);
    
        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.selection.setRange(range);
            this.currentHighlight = { id: null, range };
        }
    }
    
    handleShiftClick(currentHeader, currentNodeInfo) {
        if (!this.selectionAnchor) {
            this.selectionAnchor = currentHeader;
        }

        const nodesToSelect = this.findNodesBetween(this.selectionAnchor, currentHeader);

        this.clearSelection();

        let minLine = Infinity;
        let maxLine = -Infinity;
        let minColumn = Infinity;
        let maxColumn = -Infinity;

        nodesToSelect.forEach(node => {
            const nodeInfo = this.treeNodes.get(node);
            if (nodeInfo) {
                minLine = Math.min(minLine, nodeInfo.start.line);
                maxLine = Math.max(maxLine, nodeInfo.end.line);
                if (nodeInfo.start.line === minLine) {
                    minColumn = Math.min(minColumn, nodeInfo.start.column);
                }
                if (nodeInfo.end.line === maxLine) {
                    maxColumn = Math.max(maxColumn, nodeInfo.end.column);
                }

                this.selectedNodes.add(node);
                node.classList.add('active');
            }
        });

        const Range = ace.require('ace/range').Range;
        const range = new Range(minLine, minColumn, maxLine, maxColumn);

        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.focus();
            activeEditor.selection.setRange(range);
            activeEditor.scrollToLine(minLine, true, true);
            this.currentHighlight = { id: null, range };
        }
    }

    highlightCode(start, end) {
        const Range = ace.require('ace/range').Range;
        const range = new Range(start.line, start.column, end.line, end.column);

        const activeEditor = this.editor.getActiveEditor();
        if (activeEditor) {
            activeEditor.focus();
            activeEditor.selection.setRange(range);
            this.currentHighlight = { id: null, range };
        }
    }

    clearHighlight() {
        if (this.currentHighlight) {
            const activeEditor = this.editor.getActiveEditor();
            if (activeEditor) {
                activeEditor.session.removeMarker(this.currentHighlight.id);
            }
            this.currentHighlight = null;
        }
    }
}




// Add the styles for all node types
const style = document.createElement('style');
style.textContent = `
    .classdeclaration-node { color: #ffca28; }
    .methoddeclaration-node { color: #42a5f5; }
    .functiondeclaration-node { color: #66bb6a; }
    .arrowfunction-node { color: #4CAF50; }
    .eventlistener-node { color: #FF9800; }
    .variabledeclaration-node { color: #9C27B0; }
`;
document.head.appendChild(style);

const astSelectionStyles = document.createElement('style');
astSelectionStyles.textContent = `
    .ast-node {
        user-select: none;
        -webkit-user-select: none;
    }
    
    .ast-node.active {
        background-color: var(--accent);
        border-left: 3px solid #42a5f5;
    }
    
    .ast-node:hover {
        background-color: var(--accent-hover);
        cursor: pointer;
    }
`;
document.head.appendChild(astSelectionStyles);


const keyboardNavStyles = document.createElement('style');
keyboardNavStyles.textContent = `
    .ast-tree {
        outline: none;
    }

    .tab-content {
        outline: none;
    }

    .has-focus {
        border: 1px solid var(--accent);
        border-radius: 4px;
    }

    .ast-node.active {
        background-color: var(--accent);
        border-left: 3px solid #42a5f5;
        position: relative;
    }

    .ast-node.active::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 2px;
        background-color: #42a5f5;
    }
`;
document.head.appendChild(keyboardNavStyles);

const focusStyles = document.createElement('style');
focusStyles.textContent = `
    .ast-tree {
        outline: none;
    }

    .has-focus {
        border: 2px solid #42a5f5;
        border-radius: 4px;
    }

    .ast-node.active {
        background-color: var(--accent);
        border-left: 3px solid #42a5f5;
    }

    /* Make the focus state more visible */
    .tab-content:focus-within {
        border-color: #42a5f5;
    }
`;
document.head.appendChild(focusStyles);

const cssAstStyles = document.createElement('style');
cssAstStyles.textContent = `
    .styledeclaration-node {
        color: #E91E63;
    }
    
    .cssrule-node {
        color: #2196F3;
    }
    
    .styledeclaration-node .ast-content {
        font-weight: bold;
    }
    
    .cssrule-node .ast-content {
        font-style: italic;
    }

    .ast-node.active {
        background-color: var(--accent);
        border-left: 3px solid #42a5f5;
    }
`;
document.head.appendChild(cssAstStyles);


const lineCountStyles = document.createElement('style');
lineCountStyles.textContent = `
    .ast-node {
        position: relative;
        overflow: hidden;
    }

    .line-count-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 0;
    }

    .line-count-bar {
        height: 100%;
        background-color: rgba(255, 255, 255, 0.1);
        transition: width 0.3s ease;
    }

    .ast-toggle, .ast-content {
        position: relative;
        z-index: 1;
    }

    .line-count {
        opacity: 0.7;
        margin-left: 8px;
        font-size: 0.9em;
    }

    .ast-node:hover .line-count {
        opacity: 1;
    }

    .ast-node.active .line-count-bar {
        opacity: 0.8;
    }
`;
document.head.appendChild(lineCountStyles);


const sizeStyles = document.createElement('style');
sizeStyles.textContent = `
    .ast-node {
        position: relative;
        overflow: hidden;
        height: 24px;
        line-height: 24px;
    }

    .line-count-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 0;
    }

    .line-count-bar {
        height: 100%;
        transition: width 0.3s ease, background-color 0.3s ease;
    }

    .ast-toggle, .ast-content {
        position: relative;
        z-index: 1;
    }

    .line-count {
        opacity: 0.7;
        margin-left: 8px;
        font-size: 0.9em;
    }

    .ast-node:hover .line-count {
        opacity: 1;
    }

    .ast-node.active .line-count-bar {
        opacity: 0.8;
    }
`;
document.head.appendChild(sizeStyles);



class AICodeViewer {
    constructor(codeComparer) {
        this.parser = new CodeParser();
        this.editors = new Map();
        this.codeComparer = codeComparer;
        this.selectedBlockId = null;
        this.isUpdating = new Set();
        this.matchManager = new CodeMatchManager(this);
        this.globalListeners = new Map(); // Track global listeners for cleanup
        this.addStyles();
    }

    addStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .ai-code-container { position: relative; margin-bottom: 16px; }
            .ai-editor { width: 100%; margin-bottom: 8px; border-radius: 4px; overflow: hidden; border: 1px solid var(--border); }
            .ai-editor .ace_scrollbar-v { display: none !important; }
            .ai-editor .ace_scrollbar-h { height: 12px !important; }
            .code-block-header { display: flex; align-items: center; gap: 8px; margin-bottom: -1px; }
            .language-label { background-color: #444; color: #e6e6e6; font-size: 12px; padding: 4px 10px; border-radius: 4px 4px 0 0; }
            .code-buttons, .code-buttons-bottom { display: flex; gap: 8px; padding: 4px 0; }
            .code-buttons-bottom { margin-top: 8px; }
            .code-button { background-color: #444; color: #fff; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px; transition: background-color 0.2s; white-space: nowrap; }
            .code-button:hover { background-color: #555; }
            .code-button i { font-size: 10px; }
            .matching-functions { margin-top: 8px; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; position: relative; }
            .matching-functions-header { font-size: 12px; font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
            .refresh-button, .apply-all-button { background: var(--accent); border: none; color: white; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px; transition: all 0.2s ease; }
            .refresh-button:hover, .apply-all-button:hover { background: var(--accent-hover); transform: translateY(-1px); }
            .match-group { margin-bottom: 12px; }
            .match-group:last-child { margin-bottom: 0; }
            .match-group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; padding: 3px 8px; background: var(--bg-secondary); border-radius: 4px; }
            .match-group-title { color: var(--text-secondary); font-size: 11px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
            .match-group-apply-all { background: var(--success); border: none; color: white; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px; transition: all 0.2s ease; }
            .match-group-apply-all:hover { background: var(--success-dark); transform: translateY(-1px); }
            .match-group-apply-all:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
            .matching-function-item, .matching-style-item { height: 50px; display: grid; grid-template-columns: 1fr auto; padding: 6px 8px; border-radius: 4px; margin-bottom: 3px; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s ease; min-width: 0; }
            .matching-function-item:last-child, .matching-style-item:last-child { margin-bottom: 0; }
            .matching-function-item:hover, .matching-style-item:hover { background: var(--accent-hover); transform: translateX(2px); }
            .matching-function-item.modified { background: rgba(255, 152, 0, 0.1); border-left: 2px solid #ff9800; }
            .matching-function-item.modified:hover { background: rgba(255, 152, 0, 0.2); }
            .matching-style-item.modified { background: rgba(255, 152, 0, 0.1); border-left: 2px solid #ff9800; }
            .matching-style-item.modified:hover { background: rgba(255, 152, 0, 0.2); }
            .matching-function-item.new-item, .matching-style-item.new-item { background: rgba(46, 204, 113, 0.1); border-left: 2px solid #2ecc71; }
            .matching-function-item.new-item:hover, .matching-style-item.new-item:hover { background: rgba(46, 204, 113, 0.2); }
            .matching-function-name { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
            .name-header { display: flex; align-items: center; gap: 6px; font-family: monospace; font-size: 12px; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
            .type-icon { flex-shrink: 0; margin-right: 6px; }
            .name-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .name-actions { display: flex; align-items: center; gap: 8px; margin-top: 2px; }
            .matching-function-buttons { display: flex; gap: 4px; flex-shrink: 0; align-items: flex-start; }
            .matching-function-replace, .matching-function-compare, .matching-function-insert { background: #42a5f5; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 11px; white-space: nowrap; transition: all 0.2s ease; height: 20px; line-height: 16px; }
            .matching-function-compare { background: #ff9800; }
            .matching-function-insert { background: #2ecc71; }
            .matching-function-replace:hover, .matching-function-compare:hover, .matching-function-insert:hover { transform: scale(1.05); }
            .matching-function-copy, .matching-function-paste { flex-shrink: 0; margin: 0 4px; color: var(--text-secondary); cursor: pointer; transition: all 0.2s ease; }
            .matching-function-copy:hover, .matching-function-paste:hover { color: var(--text-primary); transform: scale(1.1); }
            .line-info { color: var(--text-secondary); font-size: 11px; display: inline-flex; align-items: center; gap: 4px; }
            .line-diff { display: inline-flex; align-items: center; padding: 1px 4px; border-radius: 3px; font-size: 10px; font-weight: bold; }
            .line-diff.positive { background: rgba(46, 204, 113, 0.1); color: #2ecc71; }
            .line-diff.negative { background: rgba(231, 76, 60, 0.1); color: #e74c3c; }
            .line-diff.equal { background: rgba(52, 152, 219, 0.1); color: #3498db; }
            .no-matches { color: var(--text-secondary); font-style: italic; font-size: 12px; padding: 4px 8px; }
        `;
        document.head.appendChild(style);

        // Store reference to global listener for cleanup
        const hoverListener = (e) => {
            if (e.target.matches('.matching-function-item, .matching-style-item')) {
                //console.log(`[AICodeViewer] Hover on ${e.target.dataset.name}, type: ${e.target.dataset.type}`);
            }
        };
        
        document.addEventListener('mouseover', hoverListener, true);
        this.globalListeners.set('mouseover', hoverListener);
    }

    createCodeBlock(container, blockId, code) {
        // Check if a block with this ID already exists and destroy it first
        if (this.editors.has(blockId)) {
            this.destroy(blockId);
        }

        const codeContainer = document.createElement('div');
        codeContainer.className = 'ai-code-container';
        codeContainer.dataset.blockId = blockId;

        const header = this.createBlockHeader(blockId);
        codeContainer.appendChild(header);

        const editorContainer = document.createElement('div');
        editorContainer.className = 'ai-editor';
        editorContainer.id = `ai-editor-${blockId}`;
        codeContainer.appendChild(editorContainer);

        const bottomButtons = this.createBottomButtonGroup(blockId);
        codeContainer.appendChild(bottomButtons);

        const matchingSection = this.createMatchingSection(blockId);
        codeContainer.appendChild(matchingSection);

        container.innerHTML = '';
        container.appendChild(codeContainer);

        const editor = this.initializeEditor(blockId, editorContainer.id);
        this.editors.set(blockId, {
            editor,
            container: codeContainer,
            matchingContent: matchingSection.querySelector('.matching-functions-content'),
            languageLabel: header.querySelector('.language-label'),
            listeners: {},
            buttons: [] // Track button listeners for cleanup
        });

        this.setupMainEditorListeners(blockId);
        this.updateContent(blockId, code, true);
        return codeContainer;
    }

    createBlockHeader(blockId) {
        const header = document.createElement('div');
        header.className = 'code-block-header';

        const languageLabel = document.createElement('div');
        languageLabel.className = 'language-label';
        languageLabel.textContent = 'text';

        const buttons = this.createButtonGroup(blockId);

        header.appendChild(languageLabel);
        header.appendChild(buttons);
        return header;
    }

    initializeEditor(blockId, containerId) {
        const editor = ace.edit(containerId);
        editor.setTheme("ace/theme/monokai");
        editor.setShowPrintMargin(false);
        editor.setOptions({
            readOnly: true,
            highlightActiveLine: false,
            highlightSelectedWord: false,
            showGutter: true,
            fontSize: 14,
            fontFamily: "Courier New, monospace",
            enableBasicAutocompletion: false,
            enableSnippets: false,
            enableLiveAutocompletion: false,
            maxLines: Infinity,
            minLines: 1
        });
        editor.renderer.setScrollMargin(0, 0, 0, 0);
        editor.session.setUseWorker(false);
        return editor;
    }

    createButtonGroup(blockId) {
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'code-buttons';

        // Store button references and handlers for cleanup
        const buttonHandlers = [];
        const editorInfo = this.editors.get(blockId);

        const createButton = (icon, text, onClick) => {
            const button = document.createElement('button');
            button.className = 'code-button';
            button.innerHTML = `<i class="fas fa-${icon}"></i> ${text}`;
            
            // Store handler reference for cleanup
            const handler = () => onClick();
            button.addEventListener('click', handler);
            buttonHandlers.push({ element: button, event: 'click', handler });
            
            return button;
        };

        const buttons = [
            createButton('arrow-left', '', () => this.copyToCursor(blockId)),
            createButton('file-import', 'Replace All', () => this.replaceInEditor(blockId, 'all')),
            createButton('copy', 'Copy All', () => this.copyToClipboard(blockId))
        ];

        buttons.forEach(button => buttonsContainer.appendChild(button));
        
        // If this block already exists, store the button handlers for cleanup
        if (editorInfo) {
            editorInfo.buttons = [...(editorInfo.buttons || []), ...buttonHandlers];
        }
        
        return buttonsContainer;
    }

    createBottomButtonGroup(blockId) {
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'code-buttons code-buttons-bottom';

        // Store button references and handlers for cleanup
        const buttonHandlers = [];
        const editorInfo = this.editors.get(blockId);

        const createButton = (icon, text, onClick) => {
            const button = document.createElement('button');
            button.className = 'code-button';
            button.innerHTML = `<i class="fas fa-${icon}"></i> ${text}`;
            
            // Store handler reference for cleanup
            const handler = () => onClick();
            button.addEventListener('click', handler);
            buttonHandlers.push({ element: button, event: 'click', handler });
            
            return button;
        };

        const buttons = [
            createButton('arrow-left', '', () => this.copyToCursor(blockId)),
            createButton('file-import', 'Replace All', () => this.replaceInEditor(blockId, 'all')),
            createButton('copy', 'Copy All', () => this.copyToClipboard(blockId))
        ];

        buttons.forEach(button => buttonsContainer.appendChild(button));
        
        // If this block already exists, store the button handlers for cleanup
        if (editorInfo) {
            editorInfo.buttons = [...(editorInfo.buttons || []), ...buttonHandlers];
        }
        
        return buttonsContainer;
    }

    createMatchingSection(blockId) {
        const matchingSection = document.createElement('div');
        matchingSection.className = 'matching-functions';
        
        // Store button references and handlers for cleanup
        const buttonHandlers = [];
        const editorInfo = this.editors.get(blockId);
        
        matchingSection.innerHTML = `
            <div class="matching-functions-header">
                <span class="matching-title"><u>Code Blocks</u></span>
                <button class="refresh-button" data-block-id="${blockId}">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button class="apply-all-button" data-block-id="${blockId}" title="Apply all replacements and insertions">
                    <i class="fas fa-check-double"></i> All
                </button>
            </div>
            <div class="matching-functions-content"></div>
        `;

        const refreshButton = matchingSection.querySelector('.refresh-button');
        const refreshHandler = () => {
            const mainEditor = TextEditor.instance;
            mainEditor.sidePane.astViewer.handleCodeChange();
            this.matchManager.updateMatches(blockId);
        };
        refreshButton.addEventListener('click', refreshHandler);
        buttonHandlers.push({ element: refreshButton, event: 'click', handler: refreshHandler });

        const applyAllButton = matchingSection.querySelector('.apply-all-button');
        const applyAllHandler = () => this.matchManager.applyAllMatches(blockId);
        applyAllButton.addEventListener('click', applyAllHandler);
        buttonHandlers.push({ element: applyAllButton, event: 'click', handler: applyAllHandler });

        // If this block already exists, store the button handlers for cleanup
        if (editorInfo) {
            editorInfo.buttons = [...(editorInfo.buttons || []), ...buttonHandlers];
        }

        return matchingSection;
    }

    updateContent(blockId, code, createEditor = true) {
        let editorInfo = this.editors.get(blockId);
        if (!editorInfo && createEditor) {
            const editorContainer = document.getElementById(`ai-editor-${blockId}`);
            if (editorContainer) {
                const editor = this.initializeEditor(blockId, editorContainer.id);
                editorInfo = {
                    editor,
                    container: editorContainer.parentElement,
                    matchingContent: editorContainer.nextSibling.querySelector('.matching-functions-content'),
                    languageLabel: editorContainer.previousSibling.querySelector('.language-label'),
                    listeners: {},
                    buttons: []
                };
                this.editors.set(blockId, editorInfo);
            }
        }

        if (!editorInfo) return;

        const { editor, languageLabel } = editorInfo;
        const editorScrollTop = editor.getSession().getScrollTop();

        editor.session.setValue(code);
        const language = this.detectLanguage(code);
        this.updateLanguageMode(blockId, language);
        if (languageLabel) languageLabel.textContent = language;

        this.matchManager.updateContent(blockId, code);
        editor.getSession().setScrollTop(editorScrollTop);
    }

    detectLanguage(code) {
        const firstLine = code.trim().split('\n')[0];
        if (firstLine.includes('<style>')) return 'css';
        if (firstLine.includes('<?php')) return 'php';
        if (firstLine.includes('import ') || firstLine.includes('from ')) return 'python';
        if (firstLine.includes('using ')) return 'csharp';
        if (firstLine.match(/^(public |private |class)/)) return 'java';
        return 'javascript';
    }

    updateLanguageMode(blockId, language) {
        const modeMap = {
            'javascript': 'ace/mode/javascript',
            'python': 'ace/mode/python',
            'java': 'ace/mode/java',
            'php': 'ace/mode/php',
            'csharp': 'ace/mode/csharp',
            'ruby': 'ace/mode/ruby',
            'go': 'ace/mode/golang',
            'typescript': 'ace/mode/typescript',
            'css': 'ace/mode/css',
            'html': 'ace/mode/html'
        };

        const editorInfo = this.editors.get(blockId);
        if (editorInfo) {
            const mode = modeMap[language] || 'ace/mode/javascript';
            editorInfo.editor.session.setMode(mode);
        }
    }

    copyToCursor(blockId) {
        const editorInfo = this.editors.get(blockId);
        if (!editorInfo) return;

        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;

        const content = editorInfo.editor.getValue().trim();
        if (!content) return;

        try {
            const selection = activeEditor.getSelectionRange();
            activeEditor.session.replace(selection, content);
            this.showStatusMessage('Code pasted at cursor', 'replaced');

            if (mainEditor.sidePane && mainEditor.sidePane.astViewer) {
                mainEditor.sidePane.astViewer.handleCodeChange();
            }

            const buttons = editorInfo.container.querySelectorAll('.code-button');
            buttons.forEach(button => {
                if (button.querySelector('.fa-arrow-left')) {
                    const originalContent = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    setTimeout(() => button.innerHTML = originalContent, 2000);
                }
            });
        } catch (err) {
            console.error('Failed to copy to cursor:', err);
            this.showStatusMessage('Error pasting code', 'error');
        }
    }

    async copyToClipboard(blockId) {
        const editorInfo = this.editors.get(blockId);
        if (!editorInfo) return;

        try {
            const text = editorInfo.editor.getValue().trim();
            await navigator.clipboard.writeText(text);
            this.showStatusMessage('Code copied to clipboard', 'copied');
            
            const buttons = editorInfo.container.querySelectorAll('.code-button');
            buttons.forEach(button => {
                if (button.textContent.includes('Copy')) {
                    const originalContent = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    setTimeout(() => button.innerHTML = originalContent, 2000);
                }
            });
        } catch (err) {
            console.error('Failed to copy:', err);
        }
    }

    async replaceInEditor(blockId, mode = 'all') {
        const editorInfo = this.editors.get(blockId);
        if (!editorInfo) return;

        try {
            let text = editorInfo.editor.getValue().trim();
            if (!text) return;

            const mainEditor = TextEditor.instance;
            const activeEditor = mainEditor.getActiveEditor();
            if (!activeEditor) return;

            const Range = ace.require('ace/range').Range;
            const lastLine = activeEditor.session.getLength() - 1;
            const lastCol = activeEditor.session.getLine(lastLine).length;
            const fullRange = new Range(0, 0, lastLine, lastCol);

            activeEditor.session.replace(fullRange, text);
            this.showStatusMessage('Code replaced', 'replaced');
            TextEditor.instance.sidePane.astViewer.handleCodeChange();
            this.matchManager.updateMatches(blockId);
        } catch (err) {
            console.error('Failed to replace:', err);
            this.showStatusMessage('Error replacing code', 'error');
        }
    }

    showStatusMessage(message, className) {
        const statusBar = document.getElementById('statusBar');
        if (statusBar) {
            statusBar.textContent = message;
            statusBar.classList.remove('saved', 'copied', 'replaced', 'error');
            statusBar.classList.add(className);
            setTimeout(() => statusBar.classList.remove(className), 2000);
        }
    }

    /**
     * Properly clean up all event listeners and resources for a specific code block
     */
    destroy(blockId) {
        const editorInfo = this.editors.get(blockId);
        if (!editorInfo) return;

        // Remove event listeners from buttons
        if (editorInfo.buttons && editorInfo.buttons.length > 0) {
            editorInfo.buttons.forEach(({ element, event, handler }) => {
                if (element && element.removeEventListener) {
                    element.removeEventListener(event, handler);
                }
            });
        }

        // Clean up main editor listeners
        this.removeMainEditorListeners(blockId);

        // Destroy ACE editor instance
        if (editorInfo.editor) {
            editorInfo.editor.destroy();
        }

        // Remove DOM elements
        if (editorInfo.container) {
            editorInfo.container.remove();
        }

        // Remove from editors map
        this.editors.delete(blockId);
    }

    /**
     * Remove all listeners and cleanup resources
     */
    destroyAll() {
        // Clean up each editor instance
        for (const blockId of Array.from(this.editors.keys())) {
            this.destroy(blockId);
        }
        
        // Clear editors map
        this.editors.clear();
        
        // Remove global document listeners
        if (this.globalListeners.size > 0) {
            for (const [event, handler] of this.globalListeners.entries()) {
                document.removeEventListener(event, handler, true);
            }
            this.globalListeners.clear();
        }
    }

    /**
     * Remove all event listeners from the main editor for a specific block
     */
    removeMainEditorListeners(blockId) {
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor?.getActiveEditor();
        const editorInfo = this.editors.get(blockId);
        
        if (activeEditor && editorInfo && editorInfo.listeners) {
            // Remove change listener from session
            if (editorInfo.listeners.change) {
                activeEditor.session.off('change', editorInfo.listeners.change);
            }
            
            // Remove DOM event listeners
            const events = ['paste', 'cut', 'click'];
            events.forEach(event => {
                if (editorInfo.listeners[event]) {
                    activeEditor.container.removeEventListener(event, editorInfo.listeners[event]);
                }
            });
            
            // Remove selection listener
            if (editorInfo.listeners.selection) {
                activeEditor.selection.off('changeSelection', editorInfo.listeners.selection);
            }
            
            // Clear listeners object
            editorInfo.listeners = {};
        }
    }

    /**
     * Set up event listeners on the main editor for a specific block
     * Properly removes old listeners first to prevent duplicates
     */
    setupMainEditorListeners(blockId) {
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;

        const editorInfo = this.editors.get(blockId);
        if (!editorInfo) return;

        // Remove any existing listeners first to prevent duplicates
        this.removeMainEditorListeners(blockId);
        
        // Initialize listeners object if needed
        if (!editorInfo.listeners) {
            editorInfo.listeners = {};
        }

        // Create a debounced update function
        const debouncedUpdate = this.debounce(() => this.matchManager.updateMatches(blockId), 500);
        const updateHandler = () => debouncedUpdate();

        // Set up all listeners and store references
        activeEditor.session.on('change', updateHandler);
        editorInfo.listeners.change = updateHandler;

        ['paste', 'cut', 'click'].forEach(event => {
            activeEditor.container.addEventListener(event, updateHandler);
            editorInfo.listeners[event] = updateHandler;
        });

        activeEditor.selection.on('changeSelection', updateHandler);
        editorInfo.listeners.selection = updateHandler;
    }

    debounce(func, wait) {
        let timeout;
        return function (...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
}




class CodeMatchManager {
    constructor(viewer) {
        this.viewer = viewer;
        this.currentFunctions = new Map();
        this.currentStyles = new Map();
        this.currentClasses = new Map();
        this.selectedNodes = new Set();
    }

    updateContent(blockId, code) {
        const ast = this.viewer.parser.parse(code);
        this.currentFunctions.set(blockId, this.extractFunctions(ast));
        this.currentClasses.set(blockId, this.extractClasses(ast));
        this.currentStyles.set(blockId, this.extractStyles(ast));
        this.updateMatches(blockId);
    }

    extractFunctions(ast) {
        const functions = new Map();
        ast.body.filter(node => 
            node.type === 'FunctionDeclaration' || node.type === 'ArrowFunction'
        ).forEach(func => functions.set(func.fullName || func.name, func));

        ast.body.filter(node => node.type === 'ClassDeclaration').forEach(classNode => {
            if (classNode.methods) {
                classNode.methods.forEach(method => {
                    const fullName = `${classNode.name}.${method.name}`;
                    method.fullName = fullName;
                    method.parentClass = classNode.name;
                    functions.set(fullName, method);
                });
            }
        });
        return functions;
    }

    extractClasses(ast) {
        const classes = new Map();
        ast.body.forEach(node => {
            if (node.type === 'ClassDeclaration') {
                classes.set(node.name, node);
            }
        });
        return classes;
    }

    extractStyles(ast) {
        const styles = new Map();
        ast.body.forEach(node => {
            if (node.type === 'StyleDeclaration' && node.rules) {
                node.rules.forEach(rule => {
                    styles.set(rule.fullName || rule.name, rule);
                });
            }
        });
        return styles;
    }

    getCurrentState(blockId) {
        return {
            functions: this.currentFunctions.get(blockId) || new Map(),
            classes: this.currentClasses.get(blockId) || new Map(),
            styles: this.currentStyles.get(blockId) || new Map()
        };
    }

    updateMatches(blockId) {
        if (this.viewer.isUpdating.has(blockId)) return;
        this.viewer.isUpdating.add(blockId);

        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo || !editorInfo.matchingContent) {
            this.viewer.isUpdating.delete(blockId);
            return;
        }

        const state = this.getCurrentState(blockId);
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();

        if (!state.functions.size && !state.classes.size && !state.styles.size) {
            editorInfo.matchingContent.innerHTML = '<div class="no-matches">No items found</div>';
            editorInfo.container.querySelector('.apply-all-button').disabled = true;
        } else if (!activeEditor) {
            editorInfo.matchingContent.innerHTML = '<div class="no-matches">No active editor available</div>';
            editorInfo.container.querySelector('.apply-all-button').disabled = true;
        } else {
            const mainContent = activeEditor.getValue();
            const mainAst = this.viewer.parser.parse(mainContent);
            const matches = this.findMatches(state, mainAst);
            if (matches.length) {
                this.renderMatches(blockId, matches);
            } else {
                editorInfo.matchingContent.innerHTML = '<div class="no-matches">No matching items found</div>';
                editorInfo.container.querySelector('.apply-all-button').disabled = true;
            }
        }
        this.viewer.isUpdating.delete(blockId);
    }

    findMatches(state, mainAst) {
        const matches = [];
        const mainFunctions = new Map();
        const mainClasses = new Map();
        const mainStyles = new Map();

        mainAst.body.forEach(node => {
            if (node.type === 'ClassDeclaration') {
                mainClasses.set(node.name, { type: 'class', node });
                if (node.methods) {
                    node.methods.forEach(method => {
                        mainFunctions.set(`${node.name}.${method.name}`, {
                            type: 'method',
                            node: method,
                            parentClass: node
                        });
                    });
                }
            } else if (node.type === 'FunctionDeclaration' || node.type === 'ArrowFunction') {
                mainFunctions.set(node.name, { type: 'function', node });
            } else if (node.type === 'StyleDeclaration' && node.rules) {
                node.rules.forEach(rule => {
                    mainStyles.set(rule.name, { type: 'cssrule', node: rule });
                });
            }
        });

        state.classes.forEach((node, name) => {
            const isNewClass = !mainClasses.has(name);
            matches.push({
                type: 'class',
                name,
                aiNode: node,
                mainNode: isNewClass ? null : mainClasses.get(name).node,
                isNew: isNewClass,
                position: node.start.line
            });

            if (node.methods) {
                node.methods.forEach(method => {
                    const methodName = `${name}.${method.name}`;
                    const isNewMethod = !mainFunctions.has(methodName);
                    matches.push({
                        type: 'method',
                        name: methodName,
                        aiNode: method,
                        mainNode: isNewMethod ? null : mainFunctions.get(methodName).node,
                        parentClass: node,
                        isNew: isNewMethod,
                        position: method.start.line
                    });
                });
            }
        });

        state.functions.forEach((node, name) => {
            if (!name.includes('.')) {
                const isNewFunction = !mainFunctions.has(name);
                matches.push({
                    type: 'function',
                    name,
                    aiNode: node,
                    mainNode: isNewFunction ? null : mainFunctions.get(name).node,
                    isNew: isNewFunction,
                    position: node.start.line
                });
            }
        });

        state.styles.forEach((node, name) => {
            const isNewRule = !mainStyles.has(name);
            matches.push({
                type: 'cssrule',
                name,
                aiNode: node,
                mainNode: isNewRule ? null : mainStyles.get(name).node,
                isNew: isNewRule,
                position: node.start.line
            });
        });

        return matches.sort((a, b) => a.position - b.position);
    }

    renderMatches(blockId, matches) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;

        const matchingContent = editorInfo.matchingContent;
        matches.forEach(match => match._isModified = this.isMatchModified(blockId, match));

        const groupedMatches = matches.reduce((acc, match) => {
            if (!acc[match.type]) acc[match.type] = [];
            acc[match.type].push(match);
            return acc;
        }, {});

        const groupOrder = ['cssrule', 'class', 'method', 'function'];
        const groupTitles = {
            'cssrule': 'CSS Rules',
            'class': 'Classes',
            'method': 'Methods',
            'function': 'Functions'
        };

        let html = `
            <div class="matching-functions-header">
                <span class="matching-title">Code Blocks</span>
                <div class="header-buttons">
                    <button class="refresh-button" data-block-id="${blockId}">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
            </div>
        `;

        groupOrder.forEach(groupType => {
            if (groupedMatches[groupType]?.length) {
                html += this.createMatchGroup(groupType, groupTitles[groupType], groupedMatches[groupType], blockId);
            }
        });

        if (!matches.length) {
            html += '<div class="no-matches">No matching items found</div>';
        }

        matchingContent.innerHTML = html;
        this.attachMatchEventListeners(blockId, matchingContent);

        const applyAllButton = editorInfo.container.querySelector('.apply-all-button');
        if (applyAllButton) {
            applyAllButton.disabled = !matches.some(match => match.isNew || match._isModified);
        }
    }

    createMatchGroup(type, title, matches, blockId) {
        const hasModifiedItems = matches.some(match => match.isNew || match._isModified);
        return `
            <div class="match-group">
                <div class="match-group-header">
                    <span class="match-group-title">${title}</span>
                    <button class="match-group-apply-all" data-type="${type}" ${!hasModifiedItems ? 'disabled' : ''}>
                        <i class="fas fa-check"></i> Apply All ${title}
                    </button>
                </div>
                ${matches.map(match => this.createMatchItem(match, blockId)).join('')}
            </div>
        `;
    }

    createMatchItem(match, blockId) {
        const itemClass = this.getItemClass(match, blockId);
        const buttons = this.createActionButtons(match);
        const lineDiff = this.calculateLineDiff(match, blockId);

        return `
            <div class="${itemClass}" data-type="${match.type}" data-name="${match.name}" data-position="${match.position}">
                <div class="matching-function-name">
                    <div class="name-header">
                        <span class="type-icon">${this.getTypeIcon(match.type)}</span>
                        <span class="name-text">${match.name}</span>
                    </div>
                    <div class="name-actions">
                        <i class="fas fa-arrow-left matching-function-paste" title="Paste at cursor" data-item-type="${match.type}" data-item-name="${match.name}"></i>
                        <i class="fas fa-copy matching-function-copy" title="Copy to clipboard" data-item-type="${match.type}" data-item-name="${match.name}"></i>
                        ${this.createLineInfo(lineDiff)}
                    </div>
                </div>
                <div class="matching-function-buttons">${buttons}</div>
            </div>
        `;
    }

    getItemClass(match, blockId) {
        const isModified = this.isMatchModified(blockId, match);
        const baseClass = match.type === 'cssrule' ? 'matching-style-item' : 'matching-function-item';
        return `${baseClass}${isModified ? ' modified' : ''}${match.isNew ? ' new-item' : ''}`;
    }

    createActionButtons(match) {
        if (match.isNew) {
            return `
                <button class="matching-function-insert" data-item-type="${match.type}" data-item-name="${match.name}">
                    Insert
                </button>
            `;
        } else {
            return `
                <button class="matching-function-replace" data-item-type="${match.type}" data-item-name="${match.name}">
                    Replace
                </button>
                <button class="matching-function-compare" data-item-type="${match.type}" data-item-name="${match.name}">
                    Compare
                </button>
            `;
        }
    }

    createLineInfo(lineDiff) {
        let className, symbol;
        if (lineDiff.diff > 0) {
            className = 'positive';
            symbol = '+';
        } else if (lineDiff.diff < 0) {
            className = 'negative';
            symbol = '';
        } else {
            className = 'equal';
            symbol = '±';
        }
        return `
            <div class="line-info">
                <span class="line-diff ${className}">${symbol}${lineDiff.diff} lines</span>
                <span title="AI: ${lineDiff.aiLines} lines${lineDiff.mainLines ? `, Original: ${lineDiff.mainLines} lines` : ''}">
                    (${lineDiff.aiLines} lines)
                </span>
            </div>
        `;
    }

    calculateLineDiff(match, blockId) {
        const editorInfo = this.viewer.editors.get(blockId);
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();

        if (!activeEditor || !editorInfo) return { diff: 0, aiLines: 0, mainLines: 0 };

        const aiContent = this.viewer.parser.getNodeContent(editorInfo.editor.getValue(), match.aiNode);
        const mainContent = match.mainNode ? this.viewer.parser.getNodeContent(activeEditor.getValue(), match.mainNode) : '';
        const aiLines = aiContent.split('\n').length;
        const mainLines = mainContent ? mainContent.split('\n').length : 0;
        return { diff: aiLines - mainLines, aiLines, mainLines };
    }

    getTypeIcon(type) {
        const icons = {
            'class': '🔴',
            'method': '🔸',
            'function': '🔷',
            'arrowfunction': '➡️',
            'eventlistener': '👂',
            'cssrule': '🎨'
        };
        return icons[type.toLowerCase()] || '📄';
    }

    isMatchModified(blockId, match) {
        if (match.isNew) return true;

        const editorInfo = this.viewer.editors.get(blockId);
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();

        if (!activeEditor || !editorInfo) return false;

        const aiContent = editorInfo.editor.getValue();
        const mainContent = activeEditor.getValue();

        let aiNodeContent, mainNodeContent;
        if (match.type === 'method' && match.name.includes('.')) {
            const [className, methodName] = match.name.split('.');
            const aiAst = this.viewer.parser.parse(aiContent);
            const mainAst = this.viewer.parser.parse(mainContent);

            const aiClassNode = aiAst.body.find(node => 
                node.type === 'ClassDeclaration' && node.name === className
            );
            const mainClassNode = mainAst.body.find(node => 
                node.type === 'ClassDeclaration' && node.name === className
            );

            const aiMethodNode = aiClassNode?.methods?.find(m => m.name === methodName);
            const mainMethodNode = mainClassNode?.methods?.find(m => m.name === methodName);

            aiNodeContent = aiMethodNode ? this.viewer.parser.getNodeContent(aiContent, aiMethodNode) : '';
            mainNodeContent = mainMethodNode ? this.viewer.parser.getNodeContent(mainContent, mainMethodNode) : '';
        } else {
            aiNodeContent = this.viewer.parser.getNodeContent(aiContent, match.aiNode);
            mainNodeContent = match.mainNode ? this.viewer.parser.getNodeContent(mainContent, match.mainNode) : '';
        }

        if (!aiNodeContent || (!mainNodeContent && !match.mainNode)) return false;

        const aiLines = aiNodeContent.split('\n').length;
        const mainLines = mainNodeContent.split('\n').length;
        if (aiLines !== mainLines) return true;

        const normalize = content => content
            .replace(/\/\*[\s\S]*?\*\//g, '')
            .replace(/\/\/.*$/gm, '')
            .replace(/[ \t]+/g, ' ')
            .replace(/^\s+|\s+$/gm, '')
            .trim();

        return normalize(aiNodeContent) !== normalize(mainNodeContent);
    }

    applyAllMatches(blockId) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;

        const items = editorInfo.matchingContent.querySelectorAll('.matching-function-item, .matching-style-item');
        items.forEach(item => {
            const itemType = item.dataset.type;
            const itemName = item.dataset.name;
            const isNew = item.classList.contains('new-item');
            const isModified = item.classList.contains('modified');
            const position = parseInt(item.dataset.position);

            if (isNew) {
                this.insertNewItem(blockId, itemName, itemType, position);
            } else if (isModified) {
                this.replaceMatch(blockId, itemName, itemType);
            }
        });

        const mainEditor = TextEditor.instance;
        mainEditor.sidePane.astViewer.handleCodeChange();
        this.updateMatchesWithoutDebounce(blockId);
        this.viewer.showStatusMessage('All matches applied', 'replaced');
    }

    attachMatchEventListeners(blockId, matchingContent) {
        const items = matchingContent.querySelectorAll('.matching-function-item, .matching-style-item');
        items.forEach(item => {
            item.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.matching-function-buttons') &&
                    !e.target.classList.contains('matching-function-copy') &&
                    !e.target.classList.contains('matching-function-paste')) {
                    const itemType = item.dataset.type;
                    const itemName = item.dataset.name;
                    if (!item.classList.contains('new-item')) {
                        this.selectInMainEditor(itemName, itemType);
                    }
                }
            });

            const replaceButton = item.querySelector('.matching-function-replace');
            if (replaceButton) {
                replaceButton.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.replaceMatch(blockId, replaceButton.dataset.itemName, replaceButton.dataset.itemType);
                });
            }

            const compareButton = item.querySelector('.matching-function-compare');
            if (compareButton) {
                compareButton.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.compareMatch(blockId, compareButton.dataset.itemName, compareButton.dataset.itemType);
                });
            }

            const insertButton = item.querySelector('.matching-function-insert');
            if (insertButton) {
                insertButton.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    const position = parseInt(item.dataset.position);
                    this.insertNewItem(blockId, insertButton.dataset.itemName, insertButton.dataset.itemType, position);
                });
            }

            const copyButton = item.querySelector('.matching-function-copy');
            if (copyButton) {
                copyButton.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.copyItemToClipboard(blockId, copyButton.dataset.itemName, copyButton.dataset.itemType);
                });
            }

            const pasteButton = item.querySelector('.matching-function-paste');
            if (pasteButton) {
                pasteButton.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.pasteItemToEditor(blockId, pasteButton.dataset.itemName, pasteButton.dataset.itemType);
                });
            }
        });

        const groupApplyButtons = matchingContent.querySelectorAll('.match-group-apply-all');
        groupApplyButtons.forEach(button => {
            button.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                this.applyAllMatchesOfType(blockId, button.dataset.type);
            });
        });
    }

    selectInMainEditor(itemName, itemType) {
    const mainEditor = TextEditor.instance;
    const activeEditor = mainEditor.getActiveEditor();
    if (!activeEditor) return;

    const mainContent = activeEditor.getValue();
    const mainAst = this.viewer.parser.parse(mainContent);
    let mainNode = this.findNodeInAst(mainAst, itemName, itemType);

    if (mainNode) {
      const Range = ace.require('ace/range').Range;
      const mainLines = mainContent.split('\n');

      const range = new Range(
        mainNode.start.line,
        0,
        mainNode.end.line,
        mainLines[mainNode.end.line].length
      );

      // Ensure the editor is editable - corrected to avoid console warning
      activeEditor.setReadOnly(false);

      // Set the selection and scroll
      activeEditor.session.selection.clearSelection();
      activeEditor.session.selection.setRange(range);
      activeEditor.renderer.scrollToLine(mainNode.start.line, true, true, () => {});

      // Force focus switch to main editor
      setTimeout(() => {
        activeEditor.focus();
        activeEditor.textInput.focus();
        activeEditor.textInput.getElement().focus();
        activeEditor.renderer.textarea.focus();
        activeEditor.container.focus();

        const editorElement = activeEditor.container;
        const clickEvent = new MouseEvent('mousedown', {
          bubbles: true,
          cancelable: true,
          view: window
        });
        editorElement.dispatchEvent(clickEvent);

        activeEditor.session.selection.setRange(range);
      }, 50);

      this.viewer.showStatusMessage(`Selected ${itemType}: ${itemName} - ready to edit`, 'replaced');
    }
  }

    findNodeInAst(ast, itemName, itemType) {
        if (itemType === 'method' && itemName.includes('.')) {
            const [className, methodName] = itemName.split('.');
            return ast.body
                .filter(node => node.type === 'ClassDeclaration' && node.name === className)
                .flatMap(node => node.methods || [])
                .find(method => method.name === methodName);
        } else if (itemType === 'class') {
            return ast.body.find(node => node.type === 'ClassDeclaration' && node.name === itemName);
        } else if (itemType === 'cssrule') {
            return ast.body
                .filter(node => node.type === 'StyleDeclaration' && node.rules)
                .flatMap(node => node.rules)
                .find(rule => rule.name === itemName);
        } else {
            return ast.body.find(node => 
                (node.type === 'FunctionDeclaration' || node.type === 'ArrowFunction') && node.name === itemName
            );
        }
    }

    compareMatch(blockId, itemName, itemType) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;

        this.viewer.selectedBlockId = blockId;
        const aiContent = editorInfo.editor.getValue();
        const aiAst = this.viewer.parser.parse(aiContent);
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;

        const mainContent = activeEditor.getValue();
        const mainAst = this.viewer.parser.parse(mainContent);

        const aiNode = this.findNodeInAst(aiAst, itemName, itemType);
        const mainNode = this.findNodeInAst(mainAst, itemName, itemType);

        if (!aiNode || !mainNode) return;

        const aiNodeContent = this.viewer.parser.getNodeContent(aiContent, aiNode);
        const mainNodeContent = this.viewer.parser.getNodeContent(mainContent, mainNode);

        this.viewer.codeComparer.createWindow(
            mainNodeContent,
            aiNodeContent,
            itemName,
            itemType,
            () => this.replaceMatch(blockId, itemName, itemType),
            this.findMatches(this.getCurrentState(blockId), mainAst)
        );
    }

    replaceMatch(blockId, itemName, itemType) {
    const editorInfo = this.viewer.editors.get(blockId);
    if (!editorInfo) return;

    const mainEditor = TextEditor.instance;
    const activeEditor = mainEditor.getActiveEditor();
    if (!activeEditor) return;

    const mainContent = activeEditor.getValue();
    const mainAst = this.viewer.parser.parse(mainContent);
    const mainNode = this.findNodeInAst(mainAst, itemName, itemType);
    if (!mainNode) return;

    const aiContent = editorInfo.editor.getValue();
    const aiAst = this.viewer.parser.parse(aiContent);
    const aiNode = this.findNodeInAst(aiAst, itemName, itemType);
    if (!aiNode) return;

    // Get AI content with proper indentation preservation
    const aiLines = aiContent.split('\n');
    const baseIndent = aiLines[aiNode.start.line].match(/^\s*/)[0] || '';
    const contentLines = aiLines.slice(aiNode.start.line, aiNode.end.line + 1);
    // Remove base indent to get relative structure
    const rawContent = contentLines.map(line =>
      line.replace(new RegExp(`^${baseIndent}`), '')
    ).join('\n');

    // Get target indent from main editor's context
    const mainLines = mainContent.split('\n');
    const targetIndent = mainLines[mainNode.start.line].match(/^\s*/)[0] || '';

    // Apply target indent to preserve structure
    const content = rawContent.split('\n')
      .map(line => line.trim().length > 0 ? targetIndent + line : line)
      .join('\n');

    // Adjust range to replace full lines
    const Range = ace.require('ace/range').Range;
    const range = new Range(
      mainNode.start.line,
      0,                           // Start at beginning of line
      mainNode.end.line,
      mainLines[mainNode.end.line].length // End at line end
    );

    // Ensure proper spacing around replacement
    const replacement = content +
                       (mainLines[mainNode.end.line + 1]?.trim().length > 0 ? '\n' : '');

    activeEditor.session.replace(range, replacement);
    this.viewer.showStatusMessage(`${itemType} replaced`, 'replaced');
    mainEditor.sidePane.astViewer.handleCodeChange();
    this.updateMatchesWithoutDebounce(blockId);
  }

    updateMatchesWithoutDebounce(blockId) {
        if (this.viewer.isUpdating.has(blockId)) return;
        this.viewer.isUpdating.add(blockId);

        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo || !editorInfo.matchingContent) {
            this.viewer.isUpdating.delete(blockId);
            return;
        }

        const state = this.getCurrentState(blockId);
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;

        const mainContent = activeEditor.getValue();
        const mainAst = this.viewer.parser.parse(mainContent);
        const matches = this.findMatches(state, mainAst);

        matches.forEach(match => match._isModified = this.isMatchModified(blockId, match));
        this.renderMatches(blockId, matches);
        this.viewer.isUpdating.delete(blockId);
    }

    applyAllMatchesOfType(blockId, type) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;

        const items = editorInfo.matchingContent.querySelectorAll(`[data-type="${type}"]`);
        items.forEach(item => {
            const itemName = item.dataset.name;
            const isNew = item.classList.contains('new-item');
            const isModified = item.classList.contains('modified');
            const position = parseInt(item.dataset.position);

            if (isNew) {
                this.insertNewItem(blockId, itemName, type, position);
            } else if (isModified) {
                this.replaceMatch(blockId, itemName, type);
            }
        });

        const mainEditor = TextEditor.instance;
        mainEditor.sidePane.astViewer.handleCodeChange();
        this.updateMatchesWithoutDebounce(blockId);
        this.viewer.showStatusMessage(`All ${type}s applied`, 'replaced');
    }

    async copyItemToClipboard(blockId, itemName, itemType) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;

        const aiContent = editorInfo.editor.getValue();
        const aiAst = this.viewer.parser.parse(aiContent);
        const aiNode = this.findNodeInAst(aiAst, itemName, itemType);
        if (!aiNode) return;

        const content = this.viewer.parser.getNodeContent(aiContent, aiNode);
        if (!content) return;

        try {
            await navigator.clipboard.writeText(content.trim());
            this.viewer.showStatusMessage(`${itemType} copied to clipboard`, 'copied');
        } catch (err) {
            console.error('Failed to copy item:', err);
            this.viewer.showStatusMessage('Error copying item', 'error');
        }
    }

    async pasteItemToEditor(blockId, itemName, itemType) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;

        const aiContent = editorInfo.editor.getValue();
        const aiAst = this.viewer.parser.parse(aiContent);
        const aiNode = this.findNodeInAst(aiAst, itemName, itemType);
        if (!aiNode) return;

        const content = this.viewer.parser.getNodeContent(aiContent, aiNode);
        if (!content) return;

        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;

        try {
            const selection = activeEditor.getSelectionRange();
            activeEditor.session.replace(selection, content.trim());
            this.viewer.showStatusMessage(`${itemType} pasted`, 'replaced');
            if (mainEditor.sidePane && mainEditor.sidePane.astViewer) {
                mainEditor.sidePane.astViewer.handleCodeChange();
            }
        } catch (err) {
            console.error('Failed to paste item:', err);
            this.viewer.showStatusMessage('Error pasting item', 'error');
        }
    }

    insertNewItem(blockId, itemName, itemType, position) {
        const editorInfo = this.viewer.editors.get(blockId);
        if (!editorInfo) return;
    
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) return;
    
        const mainContent = activeEditor.getValue();
        const mainAst = this.viewer.parser.parse(mainContent);
        const aiContent = editorInfo.editor.getValue();
        const aiAst = this.viewer.parser.parse(aiContent);
        const aiNode = this.findNodeInAst(aiAst, itemName, itemType);
        if (!aiNode) return;
    
        // Get node content with proper indentation preservation
        const aiLines = aiContent.split('\n');
        const baseIndent = aiLines[aiNode.start.line].match(/^\s*/)[0] || '';
        const contentLines = aiLines.slice(aiNode.start.line, aiNode.end.line + 1);
        // Preserve relative indentation by removing base indent then reapplying target indent later
        const content = contentLines.map(line => {
          return line.replace(new RegExp(`^${baseIndent}`), '');
        }).join('\n');
    
        let insertLine, targetIndent = '';
        const Range = ace.require('ace/range').Range;
    
        if (itemType === 'method' && itemName.includes('.')) {
          const [className, methodName] = itemName.split('.');
          const mainClassNode = mainAst.body.find(node =>
            node.type === 'ClassDeclaration' && node.name === className
          );
          const aiClassNode = aiAst.body.find(node =>
            node.type === 'ClassDeclaration' && node.name === className
          );
    
          if (!mainClassNode) {
            // Insert entire class with proper indentation
            const classLines = aiLines.slice(aiClassNode.start.line, aiClassNode.end.line + 1);
            const classBaseIndent = aiLines[aiClassNode.start.line].match(/^\s*/)[0] || '';
            const classContent = classLines.map(line =>
              line.replace(new RegExp(`^${classBaseIndent}`), '')
            ).join('\n');
    
            insertLine = mainContent.split('\n').length;
            const mainLines = mainContent.split('\n');
            targetIndent = mainLines[mainLines.length - 1]?.match(/^\s*/)[0] || '';
    
            const indentedContent = classContent.split('\n')
              .map(line => targetIndent + line)
              .join('\n');
            const insertContent = (mainLines[insertLine - 1]?.trim().length > 0 ? '\n' : '') +
                               indentedContent +
                               '\n';
            const range = new Range(insertLine, 0, insertLine, 0);
            activeEditor.session.replace(range, insertContent);
          } else {
            // Insert method with proper indentation
            const mainLines = mainContent.split('\n');
            const existingMethods = (mainClassNode.methods || []).sort((a, b) => a.start.line - b.start.line);
            let targetIndentLine = existingMethods.length > 0
              ? existingMethods[0].start.line
              : mainClassNode.start.line + 1;
            targetIndent = mainLines[targetIndentLine].match(/^\s*/)[0] || '    ';
    
            if (existingMethods.length === 0) {
              insertLine = mainClassNode.start.line + 1;
            } else {
              const state = this.getCurrentState(blockId);
              const matches = this.findMatches(state, mainAst);
              const methodMatches = matches.filter(m =>
                m.type === 'method' && m.name.startsWith(className + '.') && m.aiNode
              ).sort((a, b) => a.position - b.position);
    
              const targetIndex = methodMatches.findIndex(m => m.name === itemName);
              const prevMatch = targetIndex > 0 ? methodMatches[targetIndex - 1] : null;
              const nextMatch = targetIndex < methodMatches.length - 1 ? methodMatches[targetIndex + 1] : null;
    
              const prevMethod = prevMatch ? existingMethods.find(m => m.name === prevMatch.name.split('.')[1]) : null;
              const nextMethod = nextMatch ? existingMethods.find(m => m.name === nextMatch.name.split('.')[1]) : null;
    
              if (prevMethod && !nextMethod) {
                insertLine = prevMethod.end.line + 1;
              } else if (nextMethod) {
                insertLine = nextMethod.start.line;
              } else if (prevMethod) {
                insertLine = prevMethod.end.line + 1;
              } else {
                const methodsAfter = methodMatches.slice(targetIndex + 1);
                const nextExisting = methodsAfter.find(m =>
                  existingMethods.some(em => em.name === m.name.split('.')[1])
                );
                if (nextExisting) {
                  const nextExistingMethod = existingMethods.find(m => m.name === nextExisting.name.split('.')[1]);
                  insertLine = nextExistingMethod.start.line;
                } else {
                  insertLine = existingMethods[existingMethods.length - 1].end.line + 1;
                }
              }
    
              if (insertLine >= mainClassNode.end.line) {
                insertLine = mainClassNode.end.line - 1;
              } else if (insertLine <= mainClassNode.start.line) {
                insertLine = mainClassNode.start.line + 1;
              }
    
              for (const method of existingMethods) {
                if (insertLine >= method.start.line && insertLine <= method.end.line) {
                  insertLine = method.end.line + 1;
                }
              }
            }
    
            // Apply target indent to preserve structure
            const indentedContent = content.split('\n')
              .map(line => line.trim().length > 0 ? targetIndent + line : line)
              .join('\n');
            const insertContent = (mainLines[insertLine - 1]?.trim().length > 0 ? '\n' : '') +
                                indentedContent +
                                '\n' +
                                (mainLines[insertLine]?.trim().length > 0 ? '\n' : '');
    
            const range = new Range(insertLine, 0, insertLine, 0);
            activeEditor.session.replace(range, insertContent);
          }
        } else if (itemType === 'cssrule') {
          const mainStyleNode = mainAst.body.find(node => node.type === 'StyleDeclaration');
          insertLine = mainStyleNode ? mainStyleNode.end.line - 1 : mainContent.split('\n').length - 1;
          targetIndent = mainContent.split('\n')[insertLine]?.match(/^\s*/)[0] || '';
    
          const indentedContent = content.split('\n')
            .map(line => targetIndent + line)
            .join('\n');
          const insertContent = (mainContent.split('\n')[insertLine - 1]?.trim().length > 0 ? '\n' : '') +
                              indentedContent +
                              '\n';
          const range = new Range(insertLine, 0, insertLine, 0);
          activeEditor.session.replace(range, insertContent);
        } else {
          insertLine = mainContent.split('\n').length;
          const mainLines = mainContent.split('\n');
          targetIndent = mainLines[mainLines.length - 1]?.match(/^\s*/)[0] || '';
    
          const indentedContent = content.split('\n')
            .map(line => targetIndent + line)
            .join('\n');
          const insertContent = (mainLines[insertLine - 1]?.trim().length > 0 ? '\n' : '') +
                              indentedContent +
                              '\n';
          const range = new Range(insertLine, 0, insertLine, 0);
          activeEditor.session.replace(range, insertContent);
        }
    
        mainEditor.sidePane.astViewer.handleCodeChange();
    
        const matchItem = editorInfo.matchingContent.querySelector(
          `[data-type="${itemType}"][data-name="${CSS.escape(itemName)}"]`
        );
        if (matchItem) {
          matchItem.classList.remove('new-item');
        }
    
        this.updateMatchesWithoutDebounce(blockId);
        this.viewer.showStatusMessage(`${itemType} inserted`, 'replaced');
   }
}



class CodeComparer {
    constructor() {
        this.window = null;
        this.currentIndex = 0;
        this.matches = [];
        this.addStyles();
    }

    addStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .compare-window {
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 8px;
                width: 800px;
                height: 600px;
                z-index: 1001;
                overflow: hidden;
                resize: both;
                min-width: 400px;
                min-height: 300px;
            }

            .compare-header {
                display: flex;
                flex-direction: column;
                padding: 10px;
                background-color: var(--bg-primary);
                border-bottom: 1px solid var(--border);
                cursor: move;
            }

            .compare-title {
                color: var(--text-primary);
                font-size: 14px;
                font-weight: bold;
                margin-bottom: 5px;
            }

            .compare-names {
                color: var(--text-secondary);
                font-size: 12px;
                margin-bottom: 5px;
            }

            .compare-controls {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .compare-buttons {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .compare-nav-button,
            .compare-replace,
            .compare-close {
                background: #444;
                border: none;
                color: white;
                padding: 4px 8px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 11px;
                transition: background-color 0.2s;
            }

            .compare-nav-button {
                padding: 2px 6px;
            }

            .compare-nav-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .compare-nav-button:hover:not(:disabled),
            .compare-replace:hover,
            .compare-close:hover {
                background: #555;
            }

            .compare-sync {
                display: flex;
                align-items: center;
                gap: 4px;
                color: var(--text-primary);
                font-size: 11px;
            }

            .compare-content {
                display: flex;
                height: calc(100% - 80px);
            }

            .compare-pane {
                flex: 1;
                padding: 10px;
                overflow-y: auto;
                overflow-x: auto;
                background-color: var(--bg-primary);
            }

            .compare-pane.left {
                border-right: 1px solid var(--border);
            }

            .compare-code {
                font-family: monospace;
                font-size: 12px;
                white-space: pre;
                margin: 0;
                tab-size: 4;
                line-height: 1.5;
            }

            .compare-pane-title {
                font-size: 12px;
                color: var(--text-secondary);
                margin-bottom: 8px;
            }

            .diff-line {
                display: flex;
                width: 100%;
            }

            .diff-content {
                flex: 1;
                white-space: pre;
            }

            .diff-highlight {
                background-color: rgba(255, 255, 0, 0.2);
            }

            .diff-add {
                background-color: rgba(0, 255, 0, 0.1);
            }

            .diff-remove {
                background-color: rgba(255, 0, 0, 0.1);
            }

            .line-number {
                color: #666;
                text-align: right;
                padding-right: 10px;
                user-select: none;
                display: inline-block;
                width: 30px;
                border-right: 1px solid #444;
                margin-right: 10px;
            }
            .compare-window.fullscreen {
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                transform: none !important;
                border-radius: 0;
                resize: none;
            }
        `;
        document.head.appendChild(style);
    }

    computeDiff(oldStr, newStr) {
        const oldLines = oldStr.split('\n');
        const newLines = newStr.split('\n');
        const changes = [];
        
        const compareLines = (a, b) => {
            const normalize = (line) => {
                return line.trim()
                    .replace(/\s+/g, ' ')
                    .replace(/['"]/g, '"')
                    .replace(/\/\*[\s\S]*?\*\//g, '')
                    .replace(/\/\/.*/g, '');
            };
            return normalize(a) === normalize(b);
        };

        let i = 0, j = 0;
        while (i < oldLines.length || j < newLines.length) {
            if (i < oldLines.length && j < newLines.length && compareLines(oldLines[i], newLines[j])) {
                changes.push({ type: 'same', oldLine: oldLines[i], newLine: newLines[j] });
                i++;
                j++;
            } else {
                let matchFound = false;
                const lookAhead = 3;

                for (let k = 1; k <= lookAhead && i + k < oldLines.length && j + k < newLines.length; k++) {
                    if (compareLines(oldLines[i], newLines[j + k])) {
                        for (let l = 0; l < k; l++) {
                            changes.push({ type: 'add', newLine: newLines[j + l] });
                        }
                        changes.push({ type: 'same', oldLine: oldLines[i], newLine: newLines[j + k] });
                        i++;
                        j += k + 1;
                        matchFound = true;
                        break;
                    } else if (compareLines(oldLines[i + k], newLines[j])) {
                        for (let l = 0; l < k; l++) {
                            changes.push({ type: 'remove', oldLine: oldLines[i + l] });
                        }
                        changes.push({ type: 'same', oldLine: oldLines[i + k], newLine: newLines[j] });
                        i += k + 1;
                        j++;
                        matchFound = true;
                        break;
                    }
                }

                if (!matchFound) {
                    if (i < oldLines.length) {
                        changes.push({ type: 'remove', oldLine: oldLines[i] });
                        i++;
                    }
                    if (j < newLines.length) {
                        changes.push({ type: 'add', newLine: newLines[j] });
                        j++;
                    }
                }
            }
        }

        return changes;
    }

    highlightCode(code, changes, isLeft) {
        const lines = code.split('\n');
        let html = '';
        
        lines.forEach((line, index) => {
            const change = changes.find(c => 
                (isLeft && c.oldLine === line) || (!isLeft && c.newLine === line)
            );
            
            let lineClass = '';
            if (change) {
                if (change.type === 'add' && !isLeft) lineClass = 'diff-add';
                else if (change.type === 'remove' && isLeft) lineClass = 'diff-remove';
                else if (change.type === 'modify') lineClass = 'diff-highlight';
            }

            html += `<div class="diff-line${lineClass ? ' ' + lineClass : ''}">`;
            html += `<span class="line-number">${index + 1}</span>`;
            html += `<span class="diff-content">${this.escapeHtml(line)}</span>`;
            html += '</div>';
        });

        return html;
    }

    createWindow(originalCode, newCode, itemName, itemType, replaceCallback, allMatches) {
        if (this.window) {
            this.window.remove();
        }

        this.baseMethodName = itemType === 'method' ? itemName.split('.')[1] : itemName;
        this.matches = allMatches.filter(match => {
            if (match.type !== itemType) return false;
            if (match.type === 'method') {
                const matchBaseName = match.name.split('.')[1];
                return matchBaseName === this.baseMethodName;
            }
            return match.name === itemName;
        });

        this.matches.sort((a, b) => {
            if (!a.parentClass || !b.parentClass) return 0;
            return a.parentClass.name.localeCompare(b.parentClass.name);
        });

        this.currentIndex = 0;
        this.originalCode = originalCode;
        this.newCode = newCode;
        this.itemName = itemName;
        this.itemType = itemType;
        this.replaceCallback = replaceCallback;

        this.window = document.createElement('div');
        this.window.className = 'compare-window';
        this.window.innerHTML = `
            <div class="compare-header">
                <div class="compare-title">Compare: ${itemType} ${itemName}</div>
                <div class="compare-names"></div>
                <div class="compare-controls">
                    <label class="compare-sync">
                        <input type="checkbox" checked> Sync Scroll
                    </label>
                    <div class="compare-buttons">
                        <button class="compare-nav-button prev">←</button>
                        <button class="compare-nav-button next">→</button>
                        <button class="compare-replace">Replace</button>
                        <button class="compare-close">×</button>
                    </div>
                </div>
            </div>
            <div class="compare-content">
                <div class="compare-pane left">
                    <div class="compare-pane-title">Original Code</div>
                    <pre class="compare-code"></pre>
                </div>
                <div class="compare-pane right">
                    <div class="compare-pane-title">New Code</div>
                    <pre class="compare-code"></pre>
                </div>
            </div>
        `;

        document.body.appendChild(this.window);
        this.setupEventListeners();
        this.updateMatchDisplay();
        this.window.style.display = 'block';
    }

    setupEventListeners() {
        const header = this.window.querySelector('.compare-header');
        const closeButton = this.window.querySelector('.compare-close');
        const leftPane = this.window.querySelector('.compare-pane.left');
        const rightPane = this.window.querySelector('.compare-pane.right');
        const replaceButton = this.window.querySelector('.compare-replace');
        const prevButton = this.window.querySelector('.compare-nav-button.prev');
        const nextButton = this.window.querySelector('.compare-nav-button.next');
        const syncCheckbox = this.window.querySelector('.compare-sync input');

        let isDragging = false;
        let initialX, initialY;
        
        
        header.addEventListener('dblclick', (e) => {
        // Ignore if clicking buttons or sync checkbox
        if (!e.target.closest('.compare-buttons') && !e.target.closest('.compare-sync')) {
            const isFullscreen = this.window.classList.contains('fullscreen');
            
            // Store original position and size before going fullscreen
            if (!isFullscreen) {
                this.window.dataset.originalStyle = this.window.getAttribute('style');
            }
            
            this.window.classList.toggle('fullscreen');
            
            // Restore original position and size when exiting fullscreen
            if (isFullscreen && this.window.dataset.originalStyle) {
                this.window.setAttribute('style', this.window.dataset.originalStyle);
                delete this.window.dataset.originalStyle;
            }
            
            // Prevent dragging during double click
            isDragging = false;
            header.style.cursor = 'move';
        }
    });

        header.addEventListener('mousedown', (e) => {
            if (!e.target.closest('.compare-buttons') && !e.target.closest('.compare-sync')) {
                isDragging = true;
                const rect = this.window.getBoundingClientRect();
                initialX = e.clientX - rect.left;
                initialY = e.clientY - rect.top;
                header.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                const newX = e.clientX - initialX;
                const newY = e.clientY - initialY;
                this.window.style.left = `${newX}px`;
                this.window.style.top = `${newY}px`;
                this.window.style.transform = 'none';
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            header.style.cursor = 'move';
        });

        const syncScroll = (source, target) => {
            if (syncCheckbox.checked) {
                target.scrollTop = source.scrollTop;
                target.scrollLeft = source.scrollLeft;
            }
        };

        leftPane.addEventListener('scroll', () => syncScroll(leftPane, rightPane));
        rightPane.addEventListener('scroll', () => syncScroll(rightPane, leftPane));

        closeButton.addEventListener('click', () => {
            this.window.style.display = 'none';
        });

        document.addEventListener('mousedown', (e) => {
            if (!this.window.contains(e.target) && this.window.style.display === 'block') {
                this.window.style.display = 'none';
            }
        });

        replaceButton.addEventListener('click', () => {
            if (this.replaceCallback) {
                this.replaceCallback();
                this.updateMatchDisplay(); // Update compare window after replace
            }
        });

        prevButton.addEventListener('click', () => {
            if (this.currentIndex > 0) {
                this.currentIndex--;
                this.updateMatchDisplay();
            }
        });

        nextButton.addEventListener('click', () => {
            if (this.currentIndex < this.matches.length - 1) {
                this.currentIndex++;
                this.updateMatchDisplay();
            }
        });
    }

    updateMatchDisplay() {
        const currentMatch = this.matches[this.currentIndex];
        const mainEditor = TextEditor.instance;
        const activeEditor = mainEditor.getActiveEditor();
        if (!activeEditor) {
            console.error('No active editor available');
            this.window.querySelector('.compare-pane.left pre').innerHTML = 'Error: No active editor';
            this.window.querySelector('.compare-pane.right pre').innerHTML = 'Error: No active editor';
            return;
        }

        let mainContent;
        if (currentMatch && currentMatch.mainNode && this.replaceCallback.parser) {
            mainContent = this.replaceCallback.parser.getNodeContent(activeEditor.getValue(), currentMatch.mainNode);
        } else {
            mainContent = this.originalCode; // Fallback to original code if no match or parser
        }

        const leftPane = this.window.querySelector('.compare-pane.left pre');
        const rightPane = this.window.querySelector('.compare-pane.right pre');

        const changes = this.computeDiff(mainContent, this.newCode);
        leftPane.innerHTML = this.highlightCode(mainContent, changes, true);
        rightPane.innerHTML = this.highlightCode(this.newCode, changes, false);

        const names = this.window.querySelector('.compare-names');
        const mainName = currentMatch && currentMatch.parentClass
            ? `${currentMatch.parentClass.name}.${currentMatch.name.split('.')[1]}`
            : (currentMatch?.name || this.itemName);
        names.textContent = `Main: ${mainName} vs AI: ${this.itemName}`;

        const prevButton = this.window.querySelector('.compare-nav-button.prev');
        const nextButton = this.window.querySelector('.compare-nav-button.next');

        if (this.matches.length > 1) {
            prevButton.style.display = 'inline-block';
            nextButton.style.display = 'inline-block';
            prevButton.disabled = this.currentIndex === 0;
            nextButton.disabled = this.currentIndex === this.matches.length - 1;
        } else {
            prevButton.style.display = 'none';
            nextButton.style.display = 'none';
        }

        const replaceButton = this.window.querySelector('.compare-replace');
        const isIdentical = changes.every(change => change.type === 'same');
        replaceButton.disabled = isIdentical;
        replaceButton.title = isIdentical ? 'No changes to apply' : 'Apply changes';
    }

    isContentModified(originalContent, newContent) {
        const normalize = (content) => {
            return content
                .replace(/\s+/g, ' ')
                .replace(/\r\n/g, '\n')
                .replace(/['"]/g, '"')
                .replace(/\/\*[\s\S]*?\*\//g, '')
                .replace(/\/\/.*/g, '')
                .trim();
        };

        const normalizedOriginal = normalize(originalContent);
        const normalizedNew = normalize(newContent);
        
        return normalizedOriginal !== normalizedNew;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    destroy() {
        if (this.window) {
            this.window.remove();
            this.window = null;
        }
        this.matches = [];
        this.currentIndex = 0;
    }
}



class CodeParser {
    constructor() {
        this.ast = null;
    }

    parse(code) {
        if (!code || !code.trim()) {
            return {
                type: 'Program',
                body: [],
                start: { line: 0, column: 0 },
                end: { line: 0, column: 0 }
            };
        }

        const lines = code.split('\n');
        const ast = {
            type: 'Program',
            body: [],
            start: { line: 0, column: 0 },
            end: { line: lines.length - 1, column: lines[lines.length - 1].length }
        };

        try {
            // First pass: extract top-level elements
            this.extractTopLevelElements(lines, ast);
            this.ast = ast;
            return ast;
        } catch (error) {
            console.error("Error during parsing:", error);
            return ast;
        }
    }

    extractTopLevelElements(lines, ast) {
        let i = 0;
        while (i < lines.length) {
            const line = lines[i];
            const trimmedLine = line.trim();

            // Skip comments and empty lines
            if (!trimmedLine || this.isComment(trimmedLine)) {
                i++;
                continue;
            }

            // Style declarations
            if (this.isStyleStart(trimmedLine)) {
                const result = this.parseStyle(lines, i);
                if (result) {
                    ast.body.push(result.node);
                    i = result.endLine + 1;
                    continue;
                }
            }

            // Class declarations
            if (this.isClassDeclaration(trimmedLine)) {
                const result = this.parseClass(lines, i);
                if (result) {
                    ast.body.push(result.node);
                    i = result.endLine + 1;
                    continue;
                }
            }

            // Function declarations
            if (this.isFunctionDeclaration(trimmedLine)) {
                const funcName = this.extractFunctionName(trimmedLine, "function");
                if (funcName) {
                    const result = this.parseFunction(lines, i, funcName, 'FunctionDeclaration');
                    if (result) {
                        ast.body.push(result.node);
                        i = result.endLine + 1;
                        continue;
                    }
                }
            }

            // Arrow functions and variable assignments
            if (this.isArrowFunction(trimmedLine) || this.isVariableAssignment(trimmedLine)) {
                const varName = this.extractVariableName(trimmedLine);
                if (varName) {
                    const result = this.parseFunction(lines, i, varName, 'ArrowFunction');
                    if (result) {
                        ast.body.push(result.node);
                        i = result.endLine + 1;
                        continue;
                    }
                }
            }

            // Event listeners
            if (this.isEventListener(trimmedLine)) {
                const listenerInfo = this.extractEventListenerInfo(trimmedLine);
                if (listenerInfo) {
                    const result = this.parseEventListener(lines, i, listenerInfo.target, listenerInfo.eventName);
                    if (result) {
                        ast.body.push(result.node);
                        i = result.endLine + 1;
                        continue;
                    }
                }
            }

            i++;
        }
    }

    // Utility methods for identifying code elements
    isComment(line) {
        return line.startsWith('//') || line.startsWith('/*') || line.startsWith('*');
    }

    isStyleStart(line) {
        return line.includes('<style>') || line === '<style>' || /^\s*<style/.test(line);
    }

    isClassDeclaration(line) {
        // More robust class detection - handles class name with various modifiers
        return /\bclass\s+\w+/.test(line);
    }

    isFunctionDeclaration(line) {
        // Better function detection - handles async, static and other modifiers
        return /\b(?:static\s+)?(?:async\s+)?function\s+\w+\s*\(/.test(line);
    }

    isArrowFunction(line) {
        // More robust arrow function detection
        return /(?:const|let|var)\s+\w+\s*=\s*(?:async\s+)?(?:\([^)]*\)|[^=]+)\s*=>/.test(line);
    }

    isVariableAssignment(line) {
        // Detect potential variable assignment with function on right side
        return /(?:const|let|var)\s+\w+\s*=\s*(?:function|\()/.test(line);
    }

    isEventListener(line) {
        // Better event listener detection
        return /\.\s*addEventListener\s*\(\s*(['"])[\w-]+\1/.test(line);
    }

    extractFunctionName(line, keyword = "function") {
        const regex = new RegExp(`\\b(?:static\\s+)?(?:async\\s+)?${keyword}\\s+(\\w+)\\s*\\(`);
        const match = line.match(regex);
        return match ? match[1] : null;
    }

    extractVariableName(line) {
        const match = line.match(/(?:const|let|var)\s+(\w+)\s*=/);
        return match ? match[1] : null;
    }

    extractEventListenerInfo(line) {
        const match = line.match(/([\w.]+)\.addEventListener\s*\(\s*(['"])([^'"]+)\2/);
        if (!match) return null;
        
        let target = match[1] || 'window';
        // Clean up the target if it's this.something or window
        if (target === 'this') target = 'this';
        else if (target === 'window') target = 'window';
        else if (target.startsWith('this.')) target = target.substring(5);
        
        return {
            target: target,
            eventName: match[3]
        };
    }

    parseStyle(lines, startLine) {
        const startLineText = lines[startLine];
        const startColumn = startLineText.indexOf('<style>');
        let endLine = startLine;
        let bracketCount = 0;
        let cssContentStart = null;
        let rules = [];

        for (let i = startLine; i < lines.length; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();

            if (trimmedLine === '<style>' || trimmedLine.includes('<style>')) {
                cssContentStart = i + 1;
            }

            if (cssContentStart !== null) {
                if (line.includes('{')) {
                    bracketCount += (line.match(/{/g) || []).length;
                }
                if (line.includes('}')) {
                    bracketCount -= (line.match(/}/g) || []).length;
                }
            }

            if ((trimmedLine === '</style>' || trimmedLine.includes('</style>')) && bracketCount === 0) {
                endLine = i;
                rules = this.parseCSSRules(lines, cssContentStart, endLine - 1);
                break;
            }
        }

        if (endLine > startLine) {
            return {
                node: {
                    type: 'StyleDeclaration',
                    name: '<style>',
                    rules: rules,
                    start: { line: startLine, column: startColumn },
                    end: { line: endLine, column: lines[endLine].indexOf('</style>') + 8 }
                },
                endLine: endLine
            };
        }
        return null;
    }

    parseCSSRules(lines, startLine, endLine) {
        const rules = [];
        let currentSelector = null;
        let selectorLine = null;
        let selectorColumn = null;
        let bracketCount = 0;
        let inComment = false;
        let inSelector = false;
        let selectorBuffer = [];
        
        // Helper function to sanitize and normalize selectors
        const normalizeSelector = (selector) => {
            return selector.replace(/\s+/g, ' ').trim();
        };

        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();

            if (!trimmedLine) {
                // Preserve multi-line selectors
                if (inSelector) {
                    selectorBuffer.push(' ');
                }
                continue;
            }

            // Handle CSS comments properly
            if (trimmedLine.includes('/*')) {
                const commentStart = trimmedLine.indexOf('/*');
                const commentEnd = trimmedLine.indexOf('*/', commentStart);
                
                if (commentEnd === -1) {
                    // Start of multi-line comment
                    inComment = true;
                    
                    // Process the part before the comment
                    if (commentStart > 0) {
                        const beforeComment = trimmedLine.substring(0, commentStart).trim();
                        if (beforeComment && !currentSelector) {
                            inSelector = true;
                            selectorBuffer.push(beforeComment);
                        }
                    }
                    continue;
                } else {
                    // Single line comment, process parts outside the comment
                    const beforeComment = trimmedLine.substring(0, commentStart).trim();
                    const afterComment = trimmedLine.substring(commentEnd + 2).trim();
                    
                    if (beforeComment && !currentSelector) {
                        inSelector = true;
                        selectorBuffer.push(beforeComment);
                    }
                    
                    if (afterComment) {
                        if (afterComment.includes('{')) {
                            // We have an opening bracket after the comment
                            const openBracketIndex = afterComment.indexOf('{');
                            if (openBracketIndex > 0) {
                                // There's selector content before the bracket
                                const selectorPart = afterComment.substring(0, openBracketIndex).trim();
                                selectorBuffer.push(selectorPart);
                            }
                            
                            // Start a new rule
                            currentSelector = normalizeSelector(selectorBuffer.join(' '));
                            selectorBuffer = [];
                            inSelector = false;
                            selectorLine = i;
                            selectorColumn = line.indexOf(currentSelector);
                            bracketCount = 1;
                            
                            // Check if the rule ends on the same line
                            if (afterComment.includes('}')) {
                                bracketCount = 0;
                                rules.push({
                                    type: 'CSSRule',
                                    name: currentSelector,
                                    fullName: currentSelector,
                                    start: { line: selectorLine, column: selectorColumn },
                                    end: { line: i, column: line.lastIndexOf('}') + 1 }
                                });
                                currentSelector = null;
                            }
                        } else {
                            // Continue building the selector
                            inSelector = true;
                            selectorBuffer.push(afterComment);
                        }
                    }
                    continue;
                }
            }
            
            if (trimmedLine.includes('*/')) {
                inComment = false;
                const afterComment = trimmedLine.substring(trimmedLine.indexOf('*/') + 2).trim();
                if (afterComment) {
                    if (!currentSelector) {
                        inSelector = true;
                        selectorBuffer.push(afterComment);
                    }
                }
                continue;
            }
            
            if (inComment) {
                continue;
            }

            // Handle multi-line selectors and complex rule detection
            if (!currentSelector) {
                // If we're already building a selector
                if (inSelector) {
                    const openBracketIndex = trimmedLine.indexOf('{');
                    if (openBracketIndex !== -1) {
                        // End of the selector
                        const selectorPart = trimmedLine.substring(0, openBracketIndex).trim();
                        if (selectorPart) {
                            selectorBuffer.push(selectorPart);
                        }
                        
                        currentSelector = normalizeSelector(selectorBuffer.join(' '));
                        selectorBuffer = [];
                        inSelector = false;
                        selectorLine = i;
                        selectorColumn = line.indexOf(trimmedLine) + trimmedLine.indexOf(selectorPart);
                        bracketCount = 1;
                        
                        // Check if the rule ends on the same line
                        if (trimmedLine.includes('}')) {
                            const closeBracketIndex = trimmedLine.lastIndexOf('}');
                            bracketCount = 0;
                            rules.push({
                                type: 'CSSRule',
                                name: currentSelector,
                                fullName: currentSelector,
                                start: { line: selectorLine, column: selectorColumn },
                                end: { line: i, column: line.indexOf(trimmedLine) + closeBracketIndex + 1 }
                            });
                            currentSelector = null;
                        }
                    } else {
                        // Continue building the selector
                        selectorBuffer.push(trimmedLine);
                    }
                } else {
                    // Start of a new selector
                    const openBracketIndex = trimmedLine.indexOf('{');
                    if (openBracketIndex !== -1) {
                        // Single line selector
                        const selectorText = trimmedLine.substring(0, openBracketIndex).trim();
                        currentSelector = normalizeSelector(selectorText);
                        selectorLine = i;
                        selectorColumn = line.indexOf(selectorText);
                        bracketCount = 1;
                        
                        // Check if the rule ends on the same line
                        const closeBracketIndex = trimmedLine.indexOf('}', openBracketIndex);
                        if (closeBracketIndex !== -1) {
                            bracketCount = 0;
                            rules.push({
                                type: 'CSSRule',
                                name: currentSelector,
                                fullName: currentSelector,
                                start: { line: selectorLine, column: selectorColumn },
                                end: { line: i, column: closeBracketIndex + 1 }
                            });
                            currentSelector = null;
                        }
                    } else {
                        // Start a multi-line selector
                        inSelector = true;
                        selectorBuffer.push(trimmedLine);
                    }
                }
            } else {
                // We're inside a rule body, count brackets
                const openBrackets = (trimmedLine.match(/{/g) || []).length;
                const closeBrackets = (trimmedLine.match(/}/g) || []).length;
                
                bracketCount += openBrackets;
                bracketCount -= closeBrackets;

                // Handle media queries and nested rules
                if (openBrackets > 0 && bracketCount > 1) {
                    // This could be a nested rule, we need special handling
                    // For now, we'll just count brackets and wait for the outer rule to close
                }

                if (bracketCount === 0) {
                    // Rule is complete
                    rules.push({
                        type: 'CSSRule',
                        name: currentSelector,
                        fullName: currentSelector,
                        start: { line: selectorLine, column: selectorColumn },
                        end: { line: i, column: line.lastIndexOf('}') + 1 }
                    });
                    currentSelector = null;
                    
                    // Check for another rule starting on the same line
                    const remainingLine = trimmedLine.substring(trimmedLine.lastIndexOf('}') + 1).trim();
                    if (remainingLine) {
                        const nextOpenBracket = remainingLine.indexOf('{');
                        if (nextOpenBracket !== -1) {
                            const nextSelector = remainingLine.substring(0, nextOpenBracket).trim();
                            currentSelector = normalizeSelector(nextSelector);
                            selectorLine = i;
                            selectorColumn = line.indexOf(remainingLine) + remainingLine.indexOf(nextSelector);
                            bracketCount = 1;
                            
                            // Check if this rule also ends on the same line
                            const nextCloseBracket = remainingLine.indexOf('}', nextOpenBracket);
                            if (nextCloseBracket !== -1) {
                                bracketCount = 0;
                                rules.push({
                                    type: 'CSSRule',
                                    name: currentSelector,
                                    fullName: currentSelector,
                                    start: { line: selectorLine, column: selectorColumn },
                                    end: { line: i, column: line.indexOf(remainingLine) + nextCloseBracket + 1 }
                                });
                                currentSelector = null;
                            }
                        } else {
                            // Start building the next selector
                            inSelector = true;
                            selectorBuffer = [remainingLine];
                        }
                    }
                }
            }
        }

        return rules;
    }

    parseClass(lines, startLine) {
        const line = lines[startLine];
        const classMatch = line.match(/\bclass\s+(\w+)/);
        if (!classMatch) return null;

        const className = classMatch[1];
        const classStartColumn = line.indexOf('class');
        let bracketCount = 0;
        let inClass = false;
        let endLine = startLine;

        // Get inheritance info if any
        const extendsMatch = line.match(/\bextends\s+(\w+)/);
        const extendsClass = extendsMatch ? extendsMatch[1] : null;

        for (let i = startLine; i < lines.length; i++) {
            const currentLine = lines[i];
            
            // Find class opening bracket
            if (currentLine.includes('{')) {
                inClass = true;
                bracketCount += (currentLine.match(/{/g) || []).length;
            }
            
            // Count closing brackets
            if (currentLine.includes('}')) {
                bracketCount -= (currentLine.match(/}/g) || []).length;
            }

            // Found the end of the class
            if (inClass && bracketCount === 0) {
                endLine = i;
                const methods = this.parseClassMethods(lines, startLine, endLine, className);
                
                return {
                    node: {
                        type: 'ClassDeclaration',
                        name: className,
                        extends: extendsClass,
                        methods: methods,
                        start: { line: startLine, column: classStartColumn },
                        end: { line: endLine, column: currentLine.indexOf('}') + 1 }
                    },
                    endLine: endLine
                };
            }
        }
        return null;
    }

    parseClassMethods(lines, classStartLine, classEndLine, className) {
        const methods = [];
        let inMethod = false;
        let methodStartLine = null;
        let methodName = null;
        let fullDeclaration = null;
        let startColumn = null;
        let bracketCount = 0;

        let skipToLine = null;

        for (let i = classStartLine; i <= classEndLine; i++) {
            // Skip lines until we reach the target line (to handle nested functions properly)
            if (skipToLine !== null && i < skipToLine) {
                continue;
            } else {
                skipToLine = null;
            }

            const originalLine = lines[i];
            const line = originalLine.trim();
            
            // Skip empty lines and comments
            if (!line || this.isComment(line)) {
                continue;
            }

            if (!inMethod) {
                // Handle various method declaration patterns including getters/setters and async/static
                const methodRegex = /^((?:static\s+)?(?:async\s+)?(?:get\s+)?(?:set\s+)?(\w+))\s*\([^)]*\)\s*{/;
                const methodMatch = line.match(methodRegex);
                
                // Also handle class property methods using arrow functions
                const propertyArrowMethodRegex = /^((?:static\s+)?(?:async\s+)?(?:get\s+)?(?:set\s+)?(\w+))\s*=\s*(?:\([^)]*\)|[^=]+)\s*=>\s*{/;
                const propertyArrowMatch = line.match(propertyArrowMethodRegex);
                
                const match = methodMatch || propertyArrowMatch;
                
                if (match) {
                    inMethod = true;
                    methodStartLine = i;
                    bracketCount = 1; // We've found the opening bracket for the method
                    
                    const [, fullDecl, name] = match;
                    methodName = name;
                    fullDeclaration = fullDecl.trim();
                    startColumn = originalLine.indexOf(fullDeclaration);
                    
                    methods.push({
                        type: 'MethodDeclaration',
                        name: methodName,
                        fullName: `${className}.${methodName}`,
                        parentClass: className,
                        fullDeclaration: fullDeclaration,
                        start: { line: i, column: startColumn },
                        end: null // To be filled later
                    });
                }
            } else {
                // Keep track of bracket counts to find the end of the method
                bracketCount += (line.match(/{/g) || []).length;
                bracketCount -= (line.match(/}/g) || []).length;

                if (bracketCount === 0) {
                    // We've found the end of the method
                    methods[methods.length - 1].end = {
                        line: i,
                        column: originalLine.indexOf('}') + 1
                    };
                    
                    // Reset for next method
                    inMethod = false;
                    methodStartLine = null;
                    methodName = null;
                    
                    // Make sure we don't miss methods that are defined immediately after
                    skipToLine = i + 1;
                }
            }
        }

        return methods;
    }

    parseFunction(lines, startLine, name, type) {
        let bracketCount = 0;
        let inFunction = false;
        let endLine = startLine;
        let bracketFoundInFirstLine = false;

        const line = lines[startLine];
        let startColumn;
        let fullDeclaration;

        // Determine the type of function and extract its declaration
        if (type === 'FunctionDeclaration') {
            const funcRegex = /((?:static\s+)?(?:async\s+)?function\s+\w+\s*\([^)]*\))/;
            const match = line.match(funcRegex);
            if (match) {
                fullDeclaration = match[1];
                startColumn = line.indexOf(match[1]);
                bracketFoundInFirstLine = line.indexOf('{') !== -1;
                if (bracketFoundInFirstLine) {
                    bracketCount = 1;
                    inFunction = true;
                }
            }
        } else if (type === 'ArrowFunction') {
            const arrowRegex = /((?:const|let|var)\s+\w+\s*=\s*(?:async\s+)?(?:\([^)]*\)|[^=]+)\s*=>)/;
            const match = line.match(arrowRegex);
            if (match) {
                fullDeclaration = match[1];
                startColumn = line.indexOf(match[1]);
                bracketFoundInFirstLine = line.indexOf('{') !== -1;
                if (bracketFoundInFirstLine) {
                    bracketCount = 1;
                    inFunction = true;
                }
            }
        }

        // Handle multi-line function declarations where bracket isn't on the first line
        if (!bracketFoundInFirstLine) {
            for (let i = startLine; i < lines.length; i++) {
                if (lines[i].includes('{')) {
                    inFunction = true;
                    bracketCount = 1;
                    break;
                }
            }
        }

        // Find the end of the function by counting brackets
        for (let i = startLine; i < lines.length; i++) {
            const currentLine = lines[i];
            
            // If we haven't found any brackets yet, keep looking
            if (!inFunction && currentLine.includes('{')) {
                inFunction = true;
                bracketCount += (currentLine.match(/{/g) || []).length;
            } else if (inFunction) {
                // Continue counting brackets once we're inside the function
                if (currentLine.includes('{')) {
                    bracketCount += (currentLine.match(/{/g) || []).length;
                }
                if (currentLine.includes('}')) {
                    bracketCount -= (currentLine.match(/}/g) || []).length;
                }
                
                // Check for one-line arrow functions without brackets
                if (i === startLine && type === 'ArrowFunction' && !currentLine.includes('{') && 
                    currentLine.includes('=>') && !currentLine.includes('{')) {
                    endLine = i;
                    return {
                        node: {
                            type: type,
                            name: name,
                            fullName: name,
                            fullDeclaration: fullDeclaration,
                            start: { line: startLine, column: startColumn },
                            end: { line: endLine, column: currentLine.length }
                        },
                        endLine: endLine
                    };
                }
                
                // We've found the end of the function
                if (bracketCount === 0) {
                    endLine = i;
                    return {
                        node: {
                            type: type,
                            name: name,
                            fullName: name,
                            fullDeclaration: fullDeclaration,
                            start: { line: startLine, column: startColumn },
                            end: { line: endLine, column: currentLine.indexOf('}') + 1 }
                        },
                        endLine: endLine
                    };
                }
            }
        }
        
        // If we didn't find a proper end (missing closing bracket)
        return null;
    }

    parseEventListener(lines, startLine, target, event) {
        const line = lines[startLine];
        let bracketCount = 1; // Assume we're already inside the first bracket
        let endLine = startLine;

        // Find the start of the event listener
        const listenerRegex = /([\w.]+\.addEventListener\s*\(\s*['"][^'"]+['"])/;
        const match = line.match(listenerRegex);
        const startColumn = match ? line.indexOf(match[1]) : line.indexOf('addEventListener');

        // Count brackets to find the end of the event listener
        for (let i = startLine; i < lines.length; i++) {
            const currentLine = lines[i];
            
            bracketCount += (currentLine.match(/\(/g) || []).length;
            bracketCount -= (currentLine.match(/\)/g) || []).length;

            if (bracketCount === 0) {
                endLine = i;
                return {
                    node: {
                        type: 'EventListener',
                        name: `${target}.on${event}`,
                        fullName: `${target}.on${event}`,
                        start: { line: startLine, column: startColumn },
                        end: { line: endLine, column: currentLine.lastIndexOf(')') + 1 }
                    },
                    endLine: endLine
                };
            }
        }
        return null;
    }

    // Methods for finding nodes
    findNodeByType(type) {
        if (!this.ast) return null;
        
        for (const node of this.ast.body) {
            if (node.type === type) return node;
        }
        return null;
    }

    findNodesByType(type) {
        if (!this.ast) return [];
        
        const results = [];
        const queue = [...this.ast.body];
        
        while (queue.length > 0) {
            const node = queue.shift();
            if (node.type === type) results.push(node);
            
            if (node.type === 'ClassDeclaration' && node.methods) {
                queue.push(...node.methods);
            }
            if (node.type === 'StyleDeclaration' && node.rules) {
                queue.push(...node.rules);
            }
        }
        return results;
    }

    findNodeByName(name, className = null) {
        if (!this.ast) return null;
        
        if (className) {
            const classNode = this.ast.body.find(node => 
                node.type === 'ClassDeclaration' && node.name === className
            );
            if (classNode && classNode.methods) {
                return classNode.methods.find(method => method.name === name);
            }
            return null;
        }

        for (const node of this.ast.body) {
            if (node.name === name) return node;
            
            if (node.type === 'ClassDeclaration' && node.methods) {
                const method = node.methods.find(m => m.name === name);
                if (method) return method;
            }
            if (node.type === 'StyleDeclaration' && node.rules) {
                const rule = node.rules.find(r => r.name === name);
                if (rule) return rule;
            }
        }
        return null;
    }

    findNodesByName(name) {
        if (!this.ast) return [];
        
        const results = [];
        for (const node of this.ast.body) {
            if (node.name === name) {
                results.push(node);
            }
            
            if (node.type === 'ClassDeclaration' && node.methods) {
                const matchingMethods = node.methods.filter(m => m.name === name);
                results.push(...matchingMethods);
            }
            if (node.type === 'StyleDeclaration' && node.rules) {
                const matchingRules = node.rules.filter(r => r.name === name);
                results.push(...matchingRules);
            }
        }
        return results;
    }

    findNodeByFullName(fullName) {
        if (!this.ast) return null;
        
        if (fullName.includes('.')) {
            const [className, methodName] = fullName.split('.');
            const classNode = this.ast.body.find(node => 
                node.type === 'ClassDeclaration' && node.name === className
            );
            if (classNode && classNode.methods) {
                return classNode.methods.find(method => method.name === methodName);
            }
            return null;
        }

        for (const node of this.ast.body) {
            if (node.type === 'StyleDeclaration' && node.rules) {
                const rule = node.rules.find(r => r.fullName === fullName);
                if (rule) return rule;
            }
            if (node.fullName === fullName) return node;
            if (node.type === 'ClassDeclaration' && node.methods) {
                const method = node.methods.find(m => m.fullName === fullName);
                if (method) return method;
            }
        }
        return null;
    }

    getNodeContent(code, node) {
        if (!node || !node.start || !node.end) return '';
        
        const lines = code.split('\n');
        const startLine = node.start.line;
        const endLine = node.end.line;
        const startColumn = node.start.column;
        const endColumn = node.end.column;

        if (startLine === endLine) {
            return lines[startLine].substring(startColumn, endColumn).trim();
        }

        const result = [];
        for (let i = startLine; i <= endLine; i++) {
            if (i === startLine) {
                result.push(lines[i].substring(startColumn).trimEnd());
            } else if (i === endLine) {
                result.push(lines[i].substring(0, endColumn).trimEnd());
            } else {
                result.push(lines[i].trimEnd());
            }
        }
        return result.join('\n').trim();
    }
}



// Initialize the editor
document.addEventListener('DOMContentLoaded', () => {
    new TextEditor();
    new Prompt();
});


window.addEventListener('beforeunload', (event) => {
    const confirmationMessage = 'Are you sure you want to close this page?';
    event.preventDefault();
    event.returnValue = confirmationMessage; // For older browsers
    return confirmationMessage; // For modern browsers
});


</script>
</body>
</html>
